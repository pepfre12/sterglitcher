local reanimation = loadstring([[
	local osclock=os.clock
	local tspawn=task.spawn
	local twait=task.wait
	local schar=string.char
	local ssub=string.sub
	local sfind=string.find
	local supper=string.upper
	local mrandom=math.random
	local sin=math.sin
	local cos=math.cos
	local abs=math.abs
	local rad=math.rad
	local min=math.min
	local clamp=math.clamp
	local tinsert=table.insert
	local tclear=table.clear
	local tclone=table.clone
	local tfind=table.find
	local tunpack=table.unpack
	local next=next
	local pcall=pcall
	local xpcall=xpcall
	local type=type
	local typeof=typeof
	local game=game
	local i=Instance.new 
	local v2=Vector2.new 
	local v3=Vector3.new
	local c3=Color3.new 
	local cf=CFrame.new
	local cfl=CFrame.lookAt
	local angles=CFrame.Angles
	local u2=UDim2.new 
	local e=Enum 
	local rp=RaycastParams.new 
	local cs=ColorSequence.new 
	local csk=ColorSequenceKeypoint.new 
	local sine=osclock()
	local deltaTime=0
	local v3_0=v3(0,0,0)
	local v3_101=v3(1,0,1)
	local v3_010=v3(0,1,0)
	local v3_001=v3(0,0,1)
	local cf_0=cf(0,0,0)
	local v3_xz=v3_101*10
	local v3_xzL=v3_101*250.1
	local v3_net=v3_010*25.01
	local function rs(l) 
		l=l or mrandom(8,15) 
			local s="" 
		for i=1,l do
			if mrandom(1,2)==1 then 
			s=s..schar(mrandom(65,90)) 
			else 
			s=s..schar(mrandom(97,122)) 
			end 
		end 
		return s 
	end
	local function getMetamethodFromErrorStack(userdata,f,test)
		local debug=debug or {info=function(...) return (...) end}
		local test=test or function(...) return (...) end
		local ret=nil
		xpcall(f,function()
			ret=debug.info(2,"f")
		end,userdata,nil,0)
		if (type(ret)~="function") or not test(ret) then
			return f
		end
		return ret
	end
	local insSet=getMetamethodFromErrorStack(game,function(a,b,c) a[b]=c end,function(f) local a=i("Folder") local b=rs() f(a,"Name",b) return a.Name==b end)
	local insGet=getMetamethodFromErrorStack(game,function(a,b) return a[b] end,function(f) local a=i("Folder") local b=rs() a.Name=b return f(a,"Name")==b end)
	local cfGet=getMetamethodFromErrorStack(cf_0,function(a,b) return a[b] end,function(f) return f(cf(1,2,3),"Position")==v3(1,2,3) end)
	local cfMul=getMetamethodFromErrorStack(cf_0,function(a,b) return a*b end,function(f) return angles(1,2,3)*angles(1,2,3)==f(angles(1,2,3),angles(1,2,3)) end)
	local cfAdd=getMetamethodFromErrorStack(cf_0,function(a,b) return a+b end,function(f) return cf(1,2,3)+v3(1,2,3)==f(cf(1,2,3),v3(1,2,3)) end)
	local v3Get=getMetamethodFromErrorStack(v3_0,function(a,b) return a[b] end,function(f) return v3(1,2,3).Unit==f(v3(1,2,3),"Unit") end)
	local Clone=insGet(game,"Clone")
	local ClearAllChildren=insGet(game,"ClearAllChildren")
	local Destroy=insGet(game,"Destroy")
	local Scale=insGet(i("Model"),"ScaleTo")
	local IsA=insGet(game,"IsA")
	local FindFirstChildOfClass=insGet(game,"FindFirstChildOfClass")
	local FindFirstChildWhichIsA=insGet(game,"FindFirstChildWhichIsA")
	local GetChildren=insGet(game,"GetChildren")
	local GetDescendants=insGet(game,"GetDescendants")
	local IsDescendantOf=insGet(game,"IsDescendantOf")
	local GetPropertyChangedSignal=insGet(game,"GetPropertyChangedSignal")
	local plrs=FindFirstChildOfClass(game,"Players")
	local rus=FindFirstChildOfClass(game,"RunService")
	local ws=FindFirstChildOfClass(game,"Workspace")
	local uis=FindFirstChildOfClass(game,"UserInputService")
	local gs=FindFirstChildOfClass(game,"GuiService")
	local sg=FindFirstChildOfClass(game,"StarterGui")
	local lp=insGet(plrs,"LocalPlayer")
	local pg=FindFirstChildOfClass(lp,"PlayerGui")
	local mouse=insGet(lp,"GetMouse")(lp)
	local stepped=insGet(rus,"Stepped")
	local heartbeat=insGet(rus,"Heartbeat")
	local renderstepped=insGet(rus,"RenderStepped")
	local GetPlayers=insGet(plrs,"GetPlayers")
	local Raycast=insGet(ws,"Raycast")
	local Connect=heartbeat.Connect
	local Once=heartbeat.Once
	local SetCore=insGet(sg,"SetCore")
	local SetCoreGuiEnabled=insGet(sg,"SetCoreGuiEnabled")
	local Move=i("Humanoid").Move
	local CreateHumanoidModelFromDescription=insGet(plrs,"CreateHumanoidModelFromDescription")
	local Disconnect=Connect(GetPropertyChangedSignal(game,"CreatorId"),type).Disconnect
	local Wait=heartbeat.Wait
	local GetMouseLocation=insGet(uis,"GetMouseLocation")
	local GetFocusedTextBox=insGet(uis,"GetFocusedTextBox")
	local GetMouseDelta=insGet(uis,"GetMouseDelta")
	local IsMouseButtonPressed=insGet(uis,"IsMouseButtonPressed")
	local IsKeyDown=insGet(uis,"IsKeyDown")
	local Inverse=cfGet(cf_0,"Inverse")
	local Lerp=cfGet(cf_0,"Lerp")
	local function gp(p,n,cl)
		for i,v in next,GetChildren(p) do
			if IsA(v,cl) and (insGet(v,"Name")==n) then
				return v
			end
		end
		return nil
	end
	local function timegp(p,n,c,t)
		t=osclock()+t
		while t>osclock() do
			local r=gp(p,n,c)
			if r then
			return r
			end
			Wait(stepped)
		end
		return nil
	end
	local function getNetlessVelocity(realVel)
		if v3Get(realVel,"Magnitude")>25.01 then
			realVel=v3Get(realVel,"Unit")*25.01
		end
		return realVel*v3_xz+v3_net
	end
	local sft=1/45
	local function getFallingTime(Ypos,destY,gravity)
		local velY=25.01
		local fallingTime=0
		gravity=gravity*sft
		while (Ypos>destY) or (velY>0) do
			fallingTime=fallingTime+sft
			velY=velY-gravity
			Ypos=Ypos+(velY*sft)
		end
		return fallingTime
	end
	local function getMeshOfPart(v)
		if IsA(v,"MeshPart") then
			return insGet(v,"MeshId"), insGet(v,"TextureID")
		elseif IsA(v,"BasePart") then
			v=FindFirstChildOfClass(v,"SpecialMesh")
			if v then
			return insGet(v,"MeshId"), insGet(v,"TextureId")
			end
		end
		return nil, nil
	end
	local function makeplaceholder(v)
		if typeof(v)~="Instance" then
			return nil
		end
		if not insGet(v,"Archivable") then
			insSet(v,"Archivable",true)
		end
		v=Clone(v)
		for i,v in next,GetChildren(v) do
			if IsA(v,"SpecialMesh") then
				insSet(v,"Name",rs())
				ClearAllChildren(v)
			else
				Destroy(v)
			end
		end
		insSet(v,"Name",rs())
		insSet(v,"Anchored",true)
		insSet(v,"CanCollide",false)
		insSet(v,"Transparency",0.25)
		insSet(v,"Parent",fc)
		return v
	end
	
	local c=nil
	local fc=nil
	local function stopreanimation()
		if c and fc then
			if setcharacter then
				insSet(lp,"Character",c)
			end
			Destroy(fc)
			c=nil
			if settings then
				settings().Physics.AreOwnersShown = false
				settings().Physics.AreRegionsShown = false
			end
			pcall(SetCore,sg,"ResetButtonCallback",true)
			pcall(SetCoreGuiEnabled,sg,e.CoreGuiType.Health,true)
			return true
		end
		return false
	end
	local function startreanimation(options)
		local accessorylimbs=(options.accessorylimbs or {})
		local camerasensitivity=(options.camerasensitivity or 1)
		local allowshiftlock=(options.allowshiftlock or true)
		local ctrltp=(options.ctrltp or false)
		local placeholders=(options.placeholders or true)
		local clickfling=(options.clickfling or true)
		local highlightflingtargets=(options.highlightflingtarget or true)
		local disguiscripts=(options.disguiscripts or nil)
		local discharscripts=(options.discharscripts or nil)
		local flingchangestate=(options.flingchangestate or true)
		local respawntp=(options.respawntp or true)
		local breakjointsmethod=(options.breakjointsmethod or 1)
		local setcharacter=(options.setcharacter or false)
		local charactertransparency=(options.charactertransparency or 1)
		local charactersize=(options.charactersize or 1)
		local defaultanimations=(options.defaultanimations or false)
		local debug=(options.debug or {})
		local shownownerships=(debug.shownownerships or false)
		local shownregions=(debug.shownregions or false)
		local addaccessories=(debug.addaccessories or {})

		local novoid = true --prevents parts from going under workspace.FallenPartsDestroyHeight if you control them
		local speedlimit = 3000 --makes your parts move slower if the magnitude of their velocity is higher than this
		local retVelTime = 0.51 --time that claimed parts have velocity to reclaim in case u lose them
		local walkSpeed = 16 --your walkspeed (can be changed at runtime)
		local jumpPower = 50 --your jump power (can be changed at runtime)
		local gravity = 196.2 --how fast the characters velocity decreases while falling (can be changed at runtime)
		local ctrlclicktp = ctrltp --makes you teleport where u point ur mouse cursor at when click and hold ctrl down
		local clickfling = clickfling --makes you fling the person you clicked when its available to do so
		local flingvel = v3(15000,16000,15000) --the rotation velocity that ur character will have while flinging
		
		local bindableevent=i("BindableEvent")
		Once(bindableevent.Event,stopreanimation)
		if stopreanimation() then return end
		local rayfilter={}
		local function CreateHumanoidModel()
			local fchar=CreateHumanoidModelFromDescription(plrs,i("HumanoidDescription"),e.HumanoidRigType.R6)
			local hum=gp(fchar,"Humanoid","Humanoid") or timegp(fchar,"Humanoid","Humanoid",0.5)
			local fhrp=gp(fchar,"HumanoidRootPart","BasePart") or timegp(fchar,"HumanoidRootPart","BasePart",0.5)
			local hed=gp(fchar,"Head","BasePart") or timegp(fchar,"Head","BasePart",0.5)
			local trso=gp(fchar,"Torso","BasePart") or timegp(fchar,"Torso","BasePart",0.5)
			local ram=gp(fchar,"Right Arm","BasePart") or timegp(fchar,"Right Arm","BasePart",0.5)
			local lam=gp(fchar,"Left Arm","BasePart") or timegp(fchar,"Left Arm","BasePart",0.5)
			local rlg=gp(fchar,"Right Leg","BasePart") or timegp(fchar,"Right Leg","BasePart",0.5)
			local llg=gp(fchar,"Left Leg","BasePart") or timegp(fchar,"Left Leg","BasePart",0.5)
			local rjoint=gp(fhrp,"RootJoint","Motor6D") or timegp(fhrp,"RootJoint","Motor6D",0.5)
			local nck=gp(trso,"Neck","Motor6D") or timegp(trso,"Neck","Motor6D",0.5)
			local rsh=gp(trso,"Right Shoulder","Motor6D") or timegp(trso,"Right Shoulder","Motor6D",0.5)
			local lsh=gp(trso,"Left Shoulder","Motor6D") or timegp(trso,"Left Shoulder","Motor6D",0.5)
			local rhp=gp(trso,"Right Hip","Motor6D") or timegp(trso,"Right Hip","Motor6D",0.5)
			local lhp=gp(trso,"Left Hip","Motor6D") or timegp(trso,"Left Hip","Motor6D",0.5)
			for i,v in next,GetDescendants(fchar) do
				if IsA(v,"Part") then
					insSet(v,"Transparency",charactertransparency)
					insSet(v,"CanCollide",false)
					insSet(v,"CastShadow",false)
				elseif IsA(v,"Decal") then
					insSet(v,"Transparency",charactertransparency)
				end
			end
			if defaultanimations then
				tspawn(function() wait(1)
					local animate=gp(fchar,"Animate","LocalScript")
					if animate~=nil then
						local localscript=loadstring(game:HttpGet("https://raw.githubusercontent.com/BloxinStud10/Epiconister/main/LocalAnimate.lua"))()
						localscript.LoadAnimate(animate)
					end
				end)
			end
			Scale(fchar,charactersize)
			insSet(fchar,"Name",rs())
			insSet(fchar,"Parent",ws)
			tinsert(rayfilter,fchar)
			return {
				c=fchar,
				hn=hum,
				hrp=fhrp,
				h=hed,
				t=trso,
				ra=ram,
				la=lam,
				rl=rlg,
				ll=llg,
				rj=rjoint,
				nk=nck,
				rs=rsh,
				ls=lsh,
				rh=rhp,
				lh=lhp
			}
		end
		local fct=CreateHumanoidModel()
		fc=fct.c
		c=insGet(lp,"Character")
		if not (c and IsDescendantOf(c,ws)) then return end

		local rootpart=gp(c,"HumanoidRootPart","BasePart") or gp(c,"Torso","BasePart") or gp(c,"UpperTorso","BasePart") or timegp(c,"HumanoidRootPart","BasePart",0.5) or FindFirstChildWhichIsA(c,"BasePart")
		local fhrp=fct.hrp
		if not rootpart then return end

		local cam=nil
		local function refcam()
			local newcam=insGet(ws,"CurrentCamera")
			while not newcam do
				Wait(GetPropertyChangedSignal(ws,"CurrentCamera"))
				newcam=insGet(ws,"CurrentCamera")
			end
			cam=newcam
		end
		refcam()
		local camoffset=cf()
		local camcf=insGet(cam,"CFrame")
		local enumCamS=e.CameraType.Scriptable
		local camt=insGet(cam,"CameraType")
		local camcon0=nil
		local camcon1=nil
		local camcon2=nil
		local function onnewcamera()
			refcam()
			if camcon0 then 
				Disconnect(camcon0)
				Disconnect(camcon1)
				camcon0=nil
			end
			if not c then 
				if insGet(cam,"CameraType")==enumCamS then
					insSet(cam,"CameraType",camt)
				end
				return Disconnect(camcon2) 
			end
			camcon0=Connect(GetPropertyChangedSignal(cam,"CFrame"),function()
				if insGet(cam,"CFrame")~=camcf then
					insSet(cam,"CFrame",camcf)
				end
			end)
			camcon1=Connect(GetPropertyChangedSignal(cam,"CameraType"),function()
				if insGet(cam,"CameraType")~=enumCamS then
					insSet(cam,"CameraType",enumCamS)
				end
			end)
			if insGet(cam,"CameraType")~=enumCamS then
				insSet(cam,"CameraType",enumCamS)
			end
			if insGet(cam,"CFrame")~=camcf then
				insSet(cam,"CFrame",camcf)
			end
		end
		camcon2=Connect(GetPropertyChangedSignal(ws,"CurrentCamera"),onnewcamera)
		onnewcamera()

		local rGravity=insGet(ws,"Gravity")
		Connect(GetPropertyChangedSignal(ws,"Gravity"),function()
			rGravity=insGet(ws,"Gravity")
		end)

		local fpdh=insGet(ws,"FallenPartsDestroyHeight")
		novoid=novoid and (fpdh+1)

		local Yvel=0
		local cfr=insGet(rootpart,"CFrame")
		local pos=cfGet(cfr,"Position")
		cfr=cfl(pos,pos+cfGet(cfr,"LookVector")*v3_101)
		local primarypart=nil
		local shiftlock=false
		local firstperson=false
		local xzvel=v3_0
		local v3_0150=v3_010*1.5
		local camcfLV=cfGet(camcf,"LookVector")
		local camrot=cfl(v3_0,camcfLV)
		local camcfRV=cfGet(camrot,"RightVector")
		local cammag=-v3Get((cfGet(camcf,"Position")-(pos+v3_0150)),"Magnitude")

		local R6parts={ 
			head={Name="Head"},
			torso={Name="Torso"},
			root={Name="HumanoidRootPart"},
			leftArm={Name="Left Arm"},
			rightArm={Name="Right Arm"},
			leftLeg={Name="Left Leg"},
			rightLeg={Name="Right Leg"}
		}
		rootpart=R6parts.root
		local cframes={}
		for i,v in next,R6parts do
			cframes[v]=cfr
		end
		local joints={
			{
				Name="Neck",
				Part0=R6parts.torso,Part1=R6parts.head,
				C0=cf(0,1,0,-1,0,0,0,0,1,0,1,-0),
				C1=cf(0,-0.5,0,-1,0,0,0,0,1,0,1,-0)
			},
			{
				Name="RootJoint",
				Part0=R6parts.root,Part1=R6parts.torso,
				C0=cf(0,0,0,-1,0,0,0,0,1,0,1,-0),
				C1=cf(0,0,0,-1,0,0,0,0,1,0,1,-0)
			},
			{
				Name="Right Shoulder",
				Part0=R6parts.torso,Part1=R6parts.rightArm,
				C0=cf(1,0.5,0,0,0,1,0,1,-0,-1,0,0),
				C1=cf(-0.5,0.5,0,0,0,1,0,1,-0,-1,0,0)
			},
			{
				Name="Left Shoulder",
				Part0=R6parts.torso,Part1=R6parts.leftArm,
				C0=cf(-1,0.5,0,0,0,-1,0,1,0,1,0,0),
				C1=cf(0.5,0.5,0,0,0,-1,0,1,0,1,0,0)
			},
			{
				Name="Right Hip",
				Part0=R6parts.torso,Part1=R6parts.rightLeg,
				C0=cf(1,-1,0,0,0,1,0,1,-0,-1,0,0),
				C1=cf(0.5,1,0,0,0,1,0,1,-0,-1,0,0)
			},
			{
				Name="Left Hip",
				Part0=R6parts.torso,Part1=R6parts.leftLeg,
				C0=cf(-1,-1,0,0,0,-1,0,1,0,1,0,0),
				C1=cf(-0.5,1,0,0,0,-1,0,1,0,1,0,0)
			}
		}

		local refreshedjoints={}
		local refreshjointsI=nil
		refreshjointsI=function(part)
			tinsert(refreshedjoints,part)
			for i,v in next,joints do
				local part0=v.Part0
				local part1=v.Part1
				if part1 and (part0==part) then
					cframes[part1]=cfMul(cframes[part],cfMul(v.C0,Inverse(v.C1)))
					if not tfind(refreshedjoints,part1) then
						refreshjointsI(part1)
					end
				elseif part0 and (part1==part) then
					cframes[part0]=cfMul(cframes[part],cfMul(v.C1,Inverse(v.C0)))
					if not tfind(refreshedjoints,part0) then
						refreshjointsI(part0)
					end
				end
			end
		end
		refreshjointsI(rootpart)
		tclear(refreshedjoints)

		local attachments={
			RightShoulderAttachment={R6parts.rightArm,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
			RightGripAttachment={R6parts.rightArm,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			LeftFootAttachment={R6parts.leftLeg,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			LeftShoulderAttachment={R6parts.leftArm,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
			LeftGripAttachment={R6parts.leftArm,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			RootAttachment={rootpart,cf(0,0,0,1,0,0,0,1,0,0,0,1)},
			RightFootAttachment={R6parts.rightLeg,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			NeckAttachment={R6parts.torso,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
			BodyFrontAttachment={R6parts.torso,cf(0,0,-0.5,1,0,0,0,1,0,0,0,1)},
			BodyBackAttachment={R6parts.torso,cf(0,0,0.5,1,0,0,0,1,0,0,0,1)},
			LeftCollarAttachment={R6parts.torso,cf(-1,1,0,1,0,0,0,1,0,0,0,1)},
			RightCollarAttachment={R6parts.torso,cf(1,1,0,1,0,0,0,1,0,0,0,1)},
			WaistFrontAttachment={R6parts.torso,cf(0,-1,-0.5,1,0,0,0,1,0,0,0,1)},
			WaistCenterAttachment={R6parts.torso,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			WaistBackAttachment={R6parts.torso,cf(0,-1,0.5,1,0,0,0,1,0,0,0,1)},
			HairAttachment={R6parts.head,cf(0,0.6,0,1,0,0,0,1,0,0,0,1)},
			HatAttachment={R6parts.head,cf(0,0.6,0,1,0,0,0,1,0,0,0,1)},
			FaceFrontAttachment={R6parts.head,cf(0,0,-0.6,1,0,0,0,1,0,0,0,1)},
			FaceCenterAttachment={R6parts.head,cf(0,0,0,1,0,0,0,1,0,0,0,1)}
		}

		local function getPart(name,blacklist)
			for i,v in next,cframes do
				if (i.Name==name) and not (blacklist and tfind(blacklist,i)) then
					return i
				end
			end
			return nil
		end

		local function getJoint(name)
			for i,v in next,joints do
				if v.Name==name then
					return v
				end
			end
			return {C0=cf_0,C1=cf_0}
		end

		local function getPartFromMesh(m,t,blacklist)
			if blacklist then
				for v,_ in next,cframes do
					if v.m and (not tfind(blacklist,v)) and sfind(v.m,m) and sfind(v.t,t) then
						return v
					end
				end
			else
				for v,_ in next,cframes do
					if v.m and sfind(v.m,m) and sfind(v.t,t) then
						return v
					end
				end
			end
			local p={m=m,t=t}
			cframes[p]=cfr
			local j={C0=cf_0,C1=cf_0,Part0=p}
			p.j=j
			return p
		end

		local function getPartJoint(p)
			if cframes[p] then
				local j=p.j
				if j then
					return j
				end
				for i,v in next,joints do
					if v.Part0==p then
						return v
					end
				end
				for i,v in next,joints do
					if v.Part1==p then
						return v
					end
				end
			end
			return nil
		end

		local function getAccWeldFromMesh(m,t)
			return getPartJoint(getPartFromMesh(m,t))
		end

		local raycastparams=rp()
		raycastparams.FilterType=e.RaycastFilterType.Blacklist
		raycastparams.RespectCanCollide=true
		local characters={}
		local function refreshrayfilter()
			tclear(rayfilter)
			for i,v in next,characters do
				tinsert(rayfilter,v)
				tinsert(rayfilter,fc)
			end
			raycastparams.FilterDescendantsInstances=rayfilter
		end
		local flingtable={}
		local rootparts={}
		for i,v in next,accessorylimbs do
			v.p=getPart(v.Name)
		end
		local function makePartCons(p,t)
			if (t.p==p) and insGet(p,"Anchored") then
				t.p=nil
			end
			local con0=Connect(GetPropertyChangedSignal(p,"Anchored"),function()
				if insGet(p,"Anchored") then
					if t.p==p then
						t.c=nil
						t.p=nil
					end
				elseif not t.p then
					t.p=p
				end
			end)
			local con1=nil
			con1=Connect(insGet(p,"AncestryChanged"),function()
				if not IsDescendantOf(p,ws) then
					Disconnect(con0)
					Disconnect(con1)
					if t.p==p then
						t.p=nil
					end
				end
			end)
		end
		local ondes=nil
		ondes=function(v)
			if c and IsA(v,"Attachment") and IsDescendantOf(c,ws) then
				local v1=attachments[insGet(v,"Name")]
				if v1 then
					local p=insGet(v,"Parent")
					if insGet(p,"Parent")~=c then
						local meshid,textureid=getMeshOfPart(p)
						if meshid then
							local found=false
							for i,_ in next,cframes do
								if (meshid==i.m) and (textureid==i.t) then
									local p1=i.p
									if p1 and IsDescendantOf(p1,c) then
											if p1==p then
											found=true
											break
											end
									else
											found=true
											i.p=p
											makePartCons(p,i)
											break
									end
								else
									local j=i.j
									if j and sfind(meshid,i.m) and sfind(textureid,i.t) then
											i.m=meshid
											i.t=textureid
											i.l=insGet(p,"Position")
											i.p=p
											makePartCons(p,i)
											i.j=nil
											i.Name=insGet(p,"Name")
											j.C0=insGet(v,"CFrame")
											j.C1=v1[2]
											j.Part1=v1[1]
											tinsert(joints,j)
											found=true
											break
									end
								end
							end
							if not found then
								for i,l in next,accessorylimbs do
									if l.p and sfind(meshid,l.meshid) and sfind(textureid,l.textureid) then
											local t={Name=insGet(p,"Name"),l=insGet(p,"Position"),m=meshid,t=textureid,p=p}
											makePartCons(p,t)
											if placeholders then
											t.v=makeplaceholder(p)
											end
											cframes[t]=insGet(p,"CFrame")
											tinsert(joints,{Part0=t,Part1=l.p,C0=l.C0,C1=cf_0})
											l.p=nil
											found=true
											break
									end
								end
								if not found then
									local t={Name=insGet(p,"Name"),l=insGet(p,"Position"),m=meshid,t=textureid,p=p}
									makePartCons(p,t)
									if placeholders then
											t.v=makeplaceholder(p)
									end
									cframes[t]=insGet(p,"CFrame")
									tinsert(joints,{Part0=t,Part1=v1[1],C0=insGet(v,"CFrame"),C1=v1[2]})
								end
							end
						end
					end
				end
			end
		end

		local charcons={}
		local function onplayer(v)
			local lastc=nil
			local function oncharacter()
				local newc=insGet(v,"Character")
				if c and newc and (newc~=lastc) then
					lastc=newc
					characters[v]=newc
					refreshrayfilter()
					if setcharacter then
						insSet(v,"Character",fc)
					end
					if v==lp then
						if addaccessories then
							pcall(function()
								for i,v in pairs(addaccessories) do
									local acc=game:GetObjects("rbxassetid://"..v)[1]
									local hndle=FindFirstChildWhichIsA(acc,"Part")
									insSet(hndle,"CanCollide",false)
									local aweld=Instance.new("Weld")
									insSet(aweld,"Name","AccessoryWeld")
									insSet(aweld,"Part0",hndle)
									insSet(aweld,"Part1",gp(newc,"Head","BasePart"))
									insSet(aweld,"Parent",hndle)
									insSet(acc,"Parent",newc)
								end
							end)
						end
						if discharscripts then
							Connect(insGet(newc,"DescendantAdded"),discharscripts)
							for i,v in next,GetDescendants(newc) do
								if IsA(v,"Script") or IsA(v,"LocalScript") then
									insSet(v,"Disabled",true)
								elseif IsA(v,"BallSocketConstrait") then
									insSet(v,"Enabled",false)
								end
							end
						end
						local hrp=timegp(newc,"HumanoidRootPart","BasePart",10)
						if not (hrp and c and IsDescendantOf(newc,ws)) then return end
						c=newc
						local fi,fv=next(flingtable)
						if fi then
							if flingchangestate then
								local hum=FindFirstChildOfClass(c,"Humanoid")
								if hum then
									insGet(hum,"ChangeState")(hum,e.HumanoidStateType.Physics)
								end
							end
							for i,v in next,tclone(flingtable) do
								if not c then
									return
								end
								local startpos=insGet(i,"Position")
								local stoptime=sine+3
								while true do
									twait()
									if sine>stoptime then
											break
									end
									if insGet(i,"Anchored") or not IsDescendantOf(i,ws) then
											break
									end
									if v3Get((startpos-insGet(i,"Position")),"Magnitude")>200 then
											break
									end
									local tcf=cfAdd(insGet(i,"CFrame"),insGet(i,"AssemblyLinearVelocity")*(sin(sine*15)+1))
									if novoid and (cfGet(tcf,"Y")<novoid) then
											tcf=cfAdd(tcf,v3_010*(novoid-cfGet(tcf,"Y")))
									end
									insSet(hrp,"CFrame",tcf)
									insSet(hrp,"AssemblyLinearVelocity",insGet(i,"AssemblyLinearVelocity")*v3_101*75)
									insSet(hrp,"AssemblyAngularVelocity",flingvel)
								end
								if v then
									Destroy(v)
								end
								flingtable[i]=nil
							end
							insSet(hrp,"AssemblyLinearVelocity",v3_0)
							insSet(hrp,"AssemblyAngularVelocity",v3_0)
							insSet(hrp,"CFrame",cfr)
							twait(0.1265)
							--twait(0.2501)
						end
						if respawntp then
							local startpos=pos+v3(mrandom(-32,32),0,mrandom(-32,32))
							local dir=nil
							local poscheck=true
							while poscheck do
								poscheck=false
								for i,v in next,rootparts do
									local diff=(startpos-insGet(v,"Position"))*v3_101
									if v3Get(diff,"Magnitude")<10 then
											poscheck=true
											dir=dir or (v3Get(diff,"Unit") * 3)
											startpos=startpos+dir
									end
								end
								local diff=(startpos-pos)*v3_101
								if v3Get(diff,"Magnitude")<10 then
									poscheck=true
									dir=dir or (v3Get(diff,"Unit") * 3)
									startpos=startpos+dir
								end
							end
							startpos=cfAdd(cfGet(cfr,"Rotation"),startpos)
							insSet(hrp,"AssemblyLinearVelocity",v3_0)
							insSet(hrp,"AssemblyAngularVelocity",v3_0)
							insSet(hrp,"CFrame",startpos)
							twait(0.1265)
						end
						if newc~=c then
							return
						end
						primarypart=insGet(newc,"PrimaryPart") or hrp
						if breakjointsmethod==1 then
							insGet(newc,"BreakJoints")(newc)
							local h=FindFirstChildOfClass(newc,"Humanoid")
							if h then
								insSet(h,"Health",0)
							end
						elseif breakjointsmethod==2 then
							local h=FindFirstChildOfClass(newc,"Humanoid")
							if h then
								insSet(h,"Health",0)
							else
								insGet(newc,"BreakJoints")(newc)
							end
						else
							insGet(newc,"BreakJoints")(newc)
						end
						Connect(insGet(newc,"DescendantAdded"),ondes)
						for i,v in next,GetDescendants(newc) do
							ondes(v)
						end
					else
						local hrp=timegp(newc,"HumanoidRootPart","BasePart",10)
						if hrp and c and IsDescendantOf(newc,ws) then
							rootparts[v]=hrp
						end
					end
				end
			end
			--charcons[v]=Connect(GetPropertyChangedSignal(v,"Character"),oncharacter)
			charcons[v]=Connect(v.CharacterAppearanceLoaded,oncharacter)
			oncharacter()
		end
		for i,v in next,GetPlayers(plrs) do if v~=lp then tspawn(onplayer,v) end end
		Connect(insGet(plrs,"PlayerAdded"),onplayer)
		onplayer(lp)
		Connect(insGet(plrs,"PlayerRemoving"),function(v)
			local charcon=charcons[v]
			if charcon then
				Disconnect(charcon)
			end
			characters[v]=nil
			rootparts[v]=nil
		end)

		local mradN05=rad(-0.5)
		local KeyCode=e.KeyCode
		local enumMLC=e.MouseBehavior.LockCenter
		local enumMB2=e.UserInputType.MouseButton2
		local enumMLCP=e.MouseBehavior.LockCurrentPosition
		local enumMD=e.MouseBehavior.Default
		local enumMW=e.UserInputType.MouseWheel
		local enumMM=e.UserInputType.MouseMovement

		local mouseBehavior=nil
		local lastMouseBehavior=insGet(uis,"MouseBehavior")
		Connect(GetPropertyChangedSignal(uis,"MouseBehavior"),function()
			if mouseBehavior and (insGet(uis,"MouseBehavior")~=mouseBehavior) then
				insSet(uis,"MouseBehavior",mouseBehavior)
			end
		end)

		local mode="default"
		local defaultmode={}
		local modes={default=defaultmode}

		local lerpsIdle=(function()end)
		local lerpsWalk=(function()end)
		local lerpsJump=(function()end)
		local lerpsFall=(function()end)

		local function addmode(key,mode)
			if (type(key)~="string") or (type(mode)~="table") then
				return
			end
			for i,v in next,mode do
				if type(v)~="function" then
					mode[i]=nil
				end
			end
			if key=="default" then
				defaultmode=mode
				modes.default=mode
				lerpsIdle=mode.idle or (function()end)
				lerpsWalk=mode.walk or (function()end)
				lerpsJump=mode.jump or (function()end)
				lerpsFall=mode.fall or (function()end)
				if mode.modeEntered then
					mode.modeEntered()
				end
			elseif #key==1 then
				key=KeyCode[supper(ssub(key,1,1))]
				modes[key]=mode
			end
		end

		local keyW=KeyCode.W
		local Wpressed=IsKeyDown(uis,keyW)
		local keyA=KeyCode.A
		local Apressed=IsKeyDown(uis,keyA)
		local keyS=KeyCode.S
		local Spressed=IsKeyDown(uis,keyS)
		local keyD=KeyCode.D
		local Dpressed=IsKeyDown(uis,keyD)
		local keySpace=KeyCode.Space
		local jumpingInput=IsKeyDown(uis,keySpace)

		local FWmovement=0
		local RTmovement=0
		local isWalking=false
		local function refreshKeyboardMovement()
			if Wpressed then if Spressed then if Dpressed then if Apressed then isWalking=false else FWmovement=0 RTmovement=1 isWalking=true end else if Apressed then FWmovement=0 RTmovement=-1 isWalking=true else isWalking=false end end else FWmovement=1 if Dpressed then if Apressed then RTmovement=0 else RTmovement=1 end else if Apressed then RTmovement=-1 else RTmovement=0 end end isWalking=true end else if Spressed then FWmovement=-1 if Dpressed then if Apressed then RTmovement=0 else RTmovement=1 end else if Apressed then RTmovement=-1 else RTmovement=0 end end isWalking=true else if Dpressed then if Apressed then isWalking=false else FWmovement=0 RTmovement=1 isWalking=true end else if Apressed then FWmovement=0 RTmovement=-1 isWalking=true else isWalking=false end end end end
		end
		refreshKeyboardMovement()

		local keyShift=KeyCode.LeftShift
		Connect(insGet(uis,"InputBegan"),function(a)
			if insGet(gs,"MenuIsOpen") or GetFocusedTextBox(uis) then
				return
			end
			a=insGet(a,"KeyCode")
			if a==keyW then
				Wpressed=true
				refreshKeyboardMovement()
			elseif a==keyA then
				Apressed=true
				refreshKeyboardMovement()
			elseif a==keyS then
				Spressed=true
				refreshKeyboardMovement()
			elseif a==keyD then
				Dpressed=true
				refreshKeyboardMovement()
			elseif a==keySpace then
				jumpingInput=true
			elseif a==keyShift then
				shiftlock=allowshiftlock and not shiftlock
			elseif modes[a] then
				if modes[mode].modeLeft then
					modes[mode].modeLeft()
				end
				if mode==a then
					mode="default"
				else
					mode=a
				end
				local modet=modes[mode]
				lerpsIdle=modet.idle or defaultmode.idle or (function()end)
				lerpsWalk=modet.walk or defaultmode.walk or (function()end)
				lerpsJump=modet.jump or defaultmode.jump or (function()end)
				lerpsFall=modet.fall or defaultmode.fall or (function()end)
				if modes[mode].modeEntered then
					modes[mode].modeEntered()
				end
			end
		end)
		Connect(insGet(uis,"InputEnded"),function(a)
			a=insGet(a,"KeyCode")
			if a==keyW then
				Wpressed=false
				refreshKeyboardMovement()
			elseif a==keyA then
				Apressed=false
				refreshKeyboardMovement()
			elseif a==keyS then
				Spressed=false
				refreshKeyboardMovement()
			elseif a==keyD then
				Dpressed=false
				refreshKeyboardMovement()
			elseif a==keySpace then
				jumpingInput=false
			end
		end)

		local thumbstickEndX=0
		local thumbstickStartY=0

		local thumbstickSizeMultiplier=0

		local jumpStartX=0
		local jumpStartY=0
		local jumpEndX=0
		local jumpEndY=0

		local thumbstickInputObject=nil
		local jumpInputObject=nil
		local cameraRotateInputObject=nil
		local cameraZoomInputObject=nil

		local thumbstickTouchStart=v3_0
		local cameraZoomInputMagnitude=0

		Connect(insGet(uis,"TouchStarted"),function(inputObject)
			if insGet(gs,"MenuIsOpen") or GetFocusedTextBox(uis) then
				return
			end

			local touchPos=insGet(inputObject,"Position")
			local touchX=v3Get(touchPos,"X")
			local touchY=v3Get(touchPos,"Y")

			if (not thumbstickInputObject) and touchX<thumbstickEndX and touchY>thumbstickStartY then
				thumbstickInputObject=inputObject
				thumbstickTouchStart=insGet(inputObject,"Position")
				isWalking=false
			elseif (not jumpInputObject) and touchY>jumpStartY and touchX>jumpStartX and touchX<jumpEndX and touchY<jumpEndY then
				jumpInputObject=inputObject
				jumpingInput=true
			elseif not cameraRotateInputObject then
				cameraRotateInputObject=inputObject
			else
				cameraZoomInputObject=inputObject
				cameraZoomInputMagnitude=v3Get(insGet(cameraRotateInputObject,"Position")-insGet(cameraZoomInputObject,"Position"),"Magnitude")
			end
		end)
		Connect(insGet(uis,"TouchMoved"),function(inputObject)
			local touchPos=insGet(inputObject,"Position")
			local touchX=v3Get(touchPos,"X")
			local touchY=v3Get(touchPos,"Y")
			if inputObject==thumbstickInputObject then
				local direction=insGet(inputObject,"Position")-thumbstickTouchStart
				local directionMag=v3Get(direction,"Magnitude")/thumbstickSizeMultiplier
				if directionMag>0.05 then
					isWalking=true
					direction=v3Get(direction,"Unit")*min(1,(directionMag-0.05)/0.95) 
					FWmovement=-v3Get(direction,"Y")
					RTmovement=v3Get(direction,"X")
				else
					isWalking=false
				end
			elseif inputObject==jumpInputObject then
				jumpingInput=touchY>jumpStartY and touchX>jumpStartX and touchX<jumpEndX and touchY<jumpEndY
			else
				if cameraZoomInputObject then
					local newMagnitude=v3Get(insGet(cameraRotateInputObject,"Position")-insGet(cameraZoomInputObject,"Position"),"Magnitude")						
					cammag=cammag+(newMagnitude-cameraZoomInputMagnitude)*0.04*(0.75-cammag/4)
					cameraZoomInputMagnitude=newMagnitude
					if cammag<0 then
						firstperson=false
					else
						cammag=0
						firstperson=true
					end
				elseif inputObject==cameraRotateInputObject then
					local rotation=GetMouseDelta(uis)*mradN05*camerasensitivity
					camcfLV=cfGet(cfMul(camrot,angles(rotation.Y,rotation.X,0)),"LookVector")
					camrot=cfl(v3_0,camcfLV)
					camcfRV=cfGet(camrot,"RightVector")
				end
			end
		end)
		Connect(insGet(uis,"TouchEnded"),function(inputObject)
			if inputObject==thumbstickInputObject then
				thumbstickInputObject=nil
				isWalking=false
			elseif inputObject==jumpInputObject then
				jumpInputObject=nil
				jumpingInput=false
			elseif inputObject==cameraRotateInputObject then
				cameraRotateInputObject=nil
				cameraZoomInputObject=nil
			elseif inputObject==cameraZoomInputObject then
				cameraZoomInputObject=nil
			end
		end)

		local function refreshTouchRegions()
			local sX=insGet(mouse,"ViewSizeX")
			local sY=insGet(mouse,"ViewSizeY")
			local isSmallScreen=min(sX,sY)<=500

			sY=sY+insGet(gs,"TopbarInset").Height

			thumbstickEndX=sX*0.4
			thumbstickStartY=(sY+0)*0.333

			if isSmallScreen then
				thumbstickSizeMultiplier=35
				jumpStartX=sX-95
				jumpStartY=sY-90
				jumpEndX=jumpStartX+70
				jumpEndY=jumpStartY+70
			else
				thumbstickSizeMultiplier=60
				jumpStartX=sX-170
				jumpStartY=sY-210
				jumpEndX=jumpStartX+120
				jumpEndY=jumpStartY+120
			end
		end
		Connect(GetPropertyChangedSignal(mouse,"ViewSizeX"),refreshTouchRegions)
		Connect(GetPropertyChangedSignal(mouse,"ViewSizeY"),refreshTouchRegions)
		Connect(GetPropertyChangedSignal(gs,"TopbarInset"),refreshTouchRegions)
		refreshTouchRegions()

		local mouseCameraMove=false
		Connect(insGet(uis,"InputChanged"),function(a,b)
			if b then return end
			local inputType=insGet(a,"UserInputType")
			if mouseCameraMove and inputType==enumMM then
				local rotation=GetMouseDelta(uis)*mradN05*camerasensitivity
				camcfLV=cfGet(cfMul(camrot,angles(rotation.Y,rotation.X,0)),"LookVector")
				camrot=cfl(v3_0,camcfLV)
				camcfRV=cfGet(camrot,"RightVector")
			elseif inputType==enumMW then
				cammag=cammag+v3Get(insGet(a,"Position"),"Z")*(0.75-cammag/4)
				if cammag<0 then
					firstperson=false
				else
					cammag=0
					firstperson=true
				end
			end
		end)

		local function predictionfling(target)
			if not c or not fc then
				return false
			end
			if typeof(target)~="Instance" then 
				target=insGet(mouse,"Target")
				if not target then
					return false
				end
			end
			if not IsDescendantOf(target,ws) then
				return false
			end
			if IsA(target,"Humanoid") or IsA(target,"BasePart") then 
				target=insGet(target,"Parent") 
				if IsA(target,"Accessory") then
					target=insGet(target,"Parent")
				end
			end
			if (target==c or target==fc) or (not IsA(target,"Model")) then
				return false
			end
			local targetpart=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart")
			if (not targetpart) or (flingtable[targetpart]~=nil) then
				return false
			end
			if highlightflingtargets then
				local h=i("Highlight")
				insSet(h,"Name",rs())
				insSet(h,"Adornee",target)
				insSet(h,"FillColor",c3(1,0,0))
				insSet(h,"OutlineColor",c3(1,0,0))
				insSet(h,"FillTransparency",0.5)
				insSet(h,"OutlineTransparency",0)
				insSet(h,"Parent",target)
				flingtable[targetpart]=h
			else
				flingtable[targetpart]=false
			end
			return true
		end

		local clickConnection=nil
		if ctrlclicktp then
			ctrlclicktp=KeyCode.LeftControl
			local tpoff=v3_010*3
			if clickfling then
				clickConnection=Connect(insGet(mouse,"Button1Down"),function()
					if insGet(mouse,"Target") then
						if IsKeyDown(uis,ctrlclicktp) then
							pos=cfGet(insGet(mouse,"Hit"),"Position")+tpoff
							cfr=cfl(pos,pos+camcfLV*v3_101)
							xzvel=v3_0
							Yvel=0
						end
					end
				end)
			else
				clickConnection=Connect(insGet(mouse,"Button1Down"),function()
					if insGet(mouse,"Target") and IsKeyDown(uis,ctrlclicktp) then
						pos=cfGet(insGet(mouse,"Hit"),"Position")+tpoff
						cfr=cfl(pos,pos+camcfLV*v3_101)
						xzvel=v3_0
						Yvel=0
					end
				end)
			end
		elseif clickfling then
			clickConnection=Connect(insGet(mouse,"Button1Down"),predictionfling)
		end

		local noYvelTime=1
		local lastsine=sine
		
		sine=osclock()
		lastsine=sine

		local function refreshjoints(v) --use this on the main part if u have parts that
			refreshjointsI(v) --are connected with each other but arent connected to rootpart
			tclear(refreshedjoints)
		end

		local legcfR=cf(1,-1,0)
		local legcfL=cf(-1,-1,0)
		local raydir=v3_010*-2
		local function raycastlegs() --this returns 2 values: right leg raycast offset, left leg raycast offset
			local rY=Raycast(ws,cfGet(cfMul(cfr,legcfR),"Position"),raydir,raycastparams)
			local lY=Raycast(ws,cfGet(cfMul(cfr,legcfL),"Position"),raydir,raycastparams)
			return rY and (v3Get(rY.Position,"Y")-(v3Get(pos,"Y")-3)) or 0,lY and (v3Get(lY.Position,"Y")-(v3Get(pos,"Y")-3)) or 0
		end

		local function velbycfrvec() --this returns 2 values: forward/backwards movement (from -1 to 1), right/left movement (from -1 to 1)
			local fw=cfGet(cfr,"LookVector")*xzvel/walkSpeed
			local rt=cfGet(cfr,"RightVector")*xzvel/walkSpeed
			return v3Get(fw,"X")+v3Get(fw,"Z"),v3Get(rt,"X")+v3Get(rt,"Z")
		end

		local lastvel=v3_0
		local velchg1=v3_0
		local function velchgbycfrvec() --this returns 2 values: forward/backwards velocity change, right/left velocity change
			velchg1=velchg1+(lastvel-xzvel) --i recommend setting velchg1 to v3_0 when u start using this function or it will look worse
			lastvel=xzvel
			velchg1=velchg1-velchg1*(deltaTime/2)
			local fw=cfGet(cfr,"LookVector")*velchg1/32
			local rt=cfGet(cfr,"RightVector")*velchg1/32
			return v3Get(fw,"X")+v3Get(fw,"Z"),v3Get(rt,"X")+v3Get(rt,"Z")
		end

		local lastYvel=0
		local velYchg1=0
		local function velYchg() --this returns Y axis velocity change
			velYchg1=clamp(velYchg1+(lastYvel-Yvel),-50,50) --i recommend setting velYchg1 to 0 when u start using this function or it will look worse
			lastYvel=Yvel
			velYchg1=velYchg1-velYchg1*(deltaTime/2)
			return velYchg1
		end

		local function rotToMouse(alpha) --this rotates ur character towards your mouse hit position
			cfr=Lerp(cfr,cfl(pos,pos*v3_010+cfGet(insGet(mouse,"Hit"),"Position")*v3_101),alpha or deltaTime)
		end

		local function glitchJoint(cftype,joint,glitchTime,from,to,alpha) 
			tspawn(function()
				local currentTime=0
				local scf=cf()
				while currentTime<=glitchTime do
					twait()
					currentTime=currentTime+1
					local from=from*100
					local to=to*100
					local cfv=cftype(mrandom(from,to)/100,mrandom(from,to)/100,mrandom(from,to)/100)
					joint.C1=Lerp(joint.C1,joint.C1*cfv,alpha or deltaTime)
				end
				joint.C1=Lerp(joint.C1,scf,0.9)
			end)
		end

		local function glitchJoints(cftype,glitchTime,from,to,alpha) 
			tspawn(function()
				local currentTime=0
				while currentTime<=glitchTime do
					twait()
					currentTime=currentTime+1
					for _,v in next,joints do
						if v.Name=="RootJoint" or v.Name=="Neck" or v.Name=="Right Shoulder" or v.Name=="Left Shoulder" or v.Name=="Right Hip" or v.Name=="Left Hip" then
							glitchJoint(cftype,v,1,from,to,alpha) 
						end
					end
				end
			end)
		end

		local function setWalkSpeed(n)
			if type(n)~="number" then
				n=16
			end
			walkSpeed=n
		end
		local function setJumpPower(n)
			if type(n)~="number" then
				n=50
			end
			jumpPower=n
		end
		local function setGravity(n)
			if type(n)~="number" then
				n=196.2
			end
			gravity=n
		end
		local function setCfr(v) --sets character cframe
			if typeof(v)=="CFrame" then
				local newpos=cfGet(v,"Position")
				camcf=cfAdd(camcf,newpos-pos)
				insSet(cam,"CFrame",camcf)
				cfr=v
				pos=newpos
			elseif typeof(v)=="Vector3" then
				camcf=cfAdd(camcf,v-pos)
				insSet(cam,"CFrame",camcf)
				cfr=cfAdd(cfGet(cfr,"Rotation"),v)
				pos=v
			end
		end
		local function lerpCfr(v,alpha) --sets character cframe in tween motion
			if typeof(v)=="CFrame" then
				local newpos=cfGet(v,"Position")
				camcf=cfAdd(camcf,newpos-pos)
				insSet(cam,"CFrame",camcf)
				cfr=Lerp(cfr,v,alpha or deltaTime)
				pos=newpos
			elseif typeof(v)=="Vector3" then
				camcf=cfAdd(camcf,v-pos)
				insSet(cam,"CFrame",camcf)
				cfr=Lerp(cfr,cfAdd(cfGet(cfr,"Rotation"),v),alpha or deltaTime)
				pos=v
			end
		end
		local function setCamOffset(v,alpha)
			if typeof(v)=="Vector3" then
				camoffset=Lerp(camoffset,cf(v+(v3_010*charactersize)),alpha or 1)
			elseif typeof(v)=="CFrame" then
				camoffset=Lerp(camoffset,v,alpha or 1)
			end
		end
		local function setScale(v)
			if typeof(v)=="Number" then
				if not c and not fc then
					return
				end
				charactersize=v
				Scale(fc,v)
			end
		end
		local function getVel() --returns character velocity
			return xzvel+v3_010*Yvel --important: use only in lerps or it might not work
		end
		local function getCamCF() --returns camera cframe
			return camcf
		end
		local function isFirstPerson() --returns true if user is in first person camera mode
			return firstperson
		end
		
		pcall(SetCoreGuiEnabled,sg,e.CoreGuiType.Health,false)
		pcall(SetCore,sg,"ResetButtonCallback",bindableevent)
		
		local con=nil
		local function mainFunction()
			if sethiddenproperty then
				sethiddenproperty(lp,"SimulationRadius",9e9)
			end
			if not c then
				for i,v in next,cframes do
					local p=i.v
					if p then
						Destroy(p)
					end
				end
				for i,v in next,flingtable do
					if v then --it could be false
						Destroy(v)
					end
				end
				for i,v in next,charcons do
					Disconnect(v)
				end
				if clickConnection then
					Disconnect(clickConnection)
				end
				mouseBehavior=nil
				insSet(uis,"MouseBehavior",enumMD)
				onnewcamera()
				local c=insGet(lp,"Character")
				if c then
					insSet(cam,"CameraSubject",FindFirstChildOfClass(c,"Humanoid"))
				end
				return con and Disconnect(con) 
			end

			sine=osclock()
			local delta=sine-lastsine
			deltaTime=min(delta*10,1)
			lastsine=sine

			if shiftlock then
				if allowshiftlock then
					mouseBehavior=enumMLC
					mouseCameraMove=true
				else
					shiftlock=false
				end
			elseif firstperson then
				mouseBehavior=enumMLC
				mouseCameraMove=true
			elseif IsMouseButtonPressed(uis,enumMB2) then
				mouseBehavior=enumMLCP
				mouseCameraMove=true
			else
				mouseBehavior=enumMD
				mouseCameraMove=false
			end
			if lastMouseBehavior~=mouseBehavior then
				lastMouseBehavior=mouseBehavior
				insSet(uis,"MouseBehavior",mouseBehavior)
			end

			local raycastresult=Raycast(ws,pos,v3_010*(fpdh-v3Get(pos,"Y")),raycastparams)
			local onground=nil
			if raycastresult then
				raycastresult=v3Get(raycastresult.Position,"Y")
				onground=v3Get(pos,"Y")-raycastresult<3.01
				if onground then
					Yvel=0
					pos=pos+v3_010*(raycastresult+3-v3Get(pos,"Y"))*min(delta*20,1)
					if jumpingInput and (jumpPower>0) then
						Yvel=jumpPower
						onground=false
					end
				else
					Yvel=Yvel-gravity*delta
					if v3Get(pos,"Y")+Yvel*delta<raycastresult then
						Yvel=0
						pos=pos+v3_010*(raycastresult+3-v3Get(pos,"Y"))
					end
				end
			else
				Yvel=0
				onground=false
			end

			if firstperson then
				if isWalking then
					if walkSpeed==0 then
						xzvel=v3_0
						if onground then
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_0)
							insSet(cam,"CFrame",camcf)
							lerpsIdle()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					else
						xzvel=v3Get(v3Get(camcfLV*v3_101,"Unit")*FWmovement+v3Get(camcfRV*v3_101,"Unit")*RTmovement,"Unit")*walkSpeed
						if onground then
							pos=pos+xzvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",xzvel)
							insSet(cam,"CFrame",camcf)
							lerpsWalk()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else 
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					end
				else
					xzvel=v3_0
					if onground then
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_0)
						insSet(cam,"CFrame",camcf)
						lerpsIdle()
						noYvelTime=min(noYvelTime+delta*0.3,1)
						xzvel=xzvel*(1-noYvelTime)
					elseif Yvel>0 then
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_010*Yvel*delta)
						insSet(cam,"CFrame",camcf)
						lerpsJump()
						noYvelTime=0
					else
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_010*Yvel*delta)
						insSet(cam,"CFrame",camcf)
						lerpsFall()
						noYvelTime=0
					end
				end
			elseif shiftlock then		
				if isWalking then
					if walkSpeed==0 then
						xzvel=v3_0
						if onground then
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_0)
							insSet(cam,"CFrame",camcf)
							lerpsIdle()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					else
						xzvel=v3Get(v3Get(camcfLV*v3_101,"Unit")*FWmovement+v3Get(camcfRV*v3_101,"Unit")*RTmovement,"Unit")*walkSpeed
						if onground then
							pos=pos+xzvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",xzvel)
							insSet(cam,"CFrame",camcf)
							lerpsWalk()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					end
				else
					xzvel=v3_0
					if onground then
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_0)
						insSet(cam,"CFrame",camcf)
						lerpsIdle()
						noYvelTime=min(noYvelTime+delta*0.3,1)
						xzvel=xzvel*(1-noYvelTime)
					elseif Yvel>0 then
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsJump()
						noYvelTime=0
					else
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsFall()
						noYvelTime=0
					end
				end
			else
				if isWalking then
					if walkSpeed==0 then
						xzvel=v3_0
						if onground then
							cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_0)
							insSet(cam,"CFrame",camcf)
							lerpsIdle()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+v3_010*Yvel*delta
							cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+v3_010*Yvel*delta
							cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					else
						xzvel=v3Get(v3Get(camcfLV*v3_101,"Unit")*FWmovement+v3Get(camcfRV*v3_101,"Unit")*RTmovement,"Unit")*walkSpeed
						if onground then
							pos=pos+xzvel*delta
							cfr=cfAdd(Lerp(cfGet(cfr,"Rotation"),cfl(v3_0,xzvel),deltaTime),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",xzvel)
							insSet(cam,"CFrame",camcf)
							lerpsWalk()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+(xzvel+(v3_010*Yvel))*delta
							cfr=cfAdd(Lerp(cfGet(cfr,"Rotation"),cfl(v3_0,xzvel),deltaTime),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+(xzvel+(v3_010*Yvel))*delta
							cfr=cfAdd(Lerp(cfGet(cfr,"Rotation"),cfl(v3_0,xzvel),deltaTime),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					end
				else
					xzvel=v3_0
					if onground then
						cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
						camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_0)
						insSet(cam,"CFrame",camcf)
						lerpsIdle()
						noYvelTime=min(noYvelTime+delta*0.3,1)
						xzvel=xzvel*(1-noYvelTime)
					elseif Yvel>0 then
						pos=pos+v3_010*Yvel*delta
						cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
						camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsJump()
						noYvelTime=0
					else
						pos=pos+v3_010*Yvel*delta
						cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
						camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsFall()
						noYvelTime=0
					end
				end
			end
			
			if not raycastresult then
				insSet(fhrp,"Velocity",v3_0)
			end

			refreshjointsI(rootpart)
			tclear(refreshedjoints)

			local idlerv=v3(sin((sine-0.0375)*16),sin(sine*16),sin((sine+0.075)*16))
			local idleoff=idlerv*0.001

			local claimpos=insGet(primarypart,"Position")
			local claimposY=v3Get(claimpos,"Y")
			for i,v in next,cframes do
				local part=i.p
				
				if part then
					if insGet(part,"ReceiveAge")==0 then
						local placeholder=i.v
						if novoid and (cfGet(v,"Y")<novoid) then
							v=cfAdd(v,v3_010*(novoid-cfGet(v,"Y")))
						end
						local lastpos=i.l
						local vel=(cfGet(v,"Position")-lastpos)/delta
						if v3Get(vel,"Magnitude")<0.15 then
							if placeholder then
								insSet(placeholder,"Parent",nil)
							end
							v=cfAdd(v,idleoff)
						elseif v3Get(vel,"Magnitude")>speedlimit then
							if placeholder then
								insSet(placeholder,"CFrame",v)
								insSet(placeholder,"Parent",ws)
							end
							vel=v3Get(vel,"Unit")*speedlimit
							v=cfAdd(cfGet(v,"Rotation"),lastpos+vel*delta)
						elseif placeholder then
							insSet(placeholder,"Parent",nil)
						end
						i.l=cfGet(v,"Position")
						local claimtime=i.c
						if claimtime then
							if sine-claimtime<retVelTime then
								insSet(part,"AssemblyLinearVelocity",(claimpos-cfGet(v,"Position"))*v3_101/getFallingTime(cfGet(v,"Y"),claimposY,rGravity)+v3_net)
							else
								insSet(part,"AssemblyLinearVelocity",getNetlessVelocity(vel*noYvelTime+xzvel))
							end
						else
							i.c=sine
							insSet(part,"AssemblyLinearVelocity",getNetlessVelocity(vel*noYvelTime+xzvel))
						end
						insSet(part,"CFrame",v)
						insSet(part,"AssemblyAngularVelocity",idlerv)
					else
						i.c=nil
						i.l=insGet(part,"Position")
						local placeholder=i.v
						if placeholder then
							insSet(placeholder,"CFrame",v)
							insSet(placeholder,"Parent",fc)
						end
					end
				else
					local placeholder=i.v
					if placeholder then
						insSet(placeholder,"CFrame",v)
						insSet(placeholder,"Parent",fc)
					end
				end
			end
			
			setWalkSpeed(fct.hn.WalkSpeed)
			setJumpPower(fct.hn.JumpPower)
			if not setcharacter then
				Move(fct.hn,insGet(FindFirstChildOfClass(c,"Humanoid"),"MoveDirection"))
			end
			
			for _,v in next,joints do
				if v.Name=="RootJoint" then
					v.C0=fct.hrp.CFrame:ToObjectSpace(fct.t.CFrame)
					v.C1=cf()
				elseif v.Name=="Neck" then
					v.C0=fct.t.CFrame:ToObjectSpace(fct.h.CFrame)
					v.C1=cf()
				elseif v.Name=="Right Shoulder" then
					v.C0=fct.t.CFrame:ToObjectSpace(fct.ra.CFrame)
					v.C1=cf()
				elseif v.Name=="Left Shoulder" then
					v.C0=fct.t.CFrame:ToObjectSpace(fct.la.CFrame)
					v.C1=cf()
				elseif v.Name=="Right Hip" then
					v.C0=fct.t.CFrame:ToObjectSpace(fct.rl.CFrame)
					v.C1=cf()
				elseif v.Name=="Left Hip" then
					v.C0=fct.t.CFrame:ToObjectSpace(fct.ll.CFrame)
					v.C1=cf()
				end
			end
			if settings then
				settings().Physics.AreOwnersShown = shownownerships
				settings().Physics.AreRegionsShown = shownregions
				settings().Physics.AllowSleep = false
			end
		end
		
		con=Connect(heartbeat,mainFunction)
		mainFunction()
		
		return {
			options=options,
			cframes=cframes,
			parts=R6parts,
			joints=joints,
			gp=gp,
			timegp=timegp,
			insSet=insSet,
			insGet=insGet,
			cfMul=cfMul,
			deadcharacter=c,
			character=fc,
			mouse=mouse,
			fling=predictionfling,
			predictionfling=predictionfling,
			refreshjoints=refreshjoints,
			raycastlegs=raycastlegs,
			velbycfrvec=velbycfrvec,
			velchgbycfrvec=velchgbycfrvec,
			velYchg=velYchg,
			addmode=addmode,
			getPart=getPart,
			getPartFromMesh=getPartFromMesh,
			getAccWeldFromMesh=getAccWeldFromMesh,
			getJoint=getJoint,
			getPartJoint=getPartJoint,
			rotToMouse=rotToMouse,
			glitchJoint=glitchJoint,
			glitchJoints=glitchJoints,
			setWalkSpeed=setWalkSpeed,
			setJumpPower=setJumpPower,
			setGravity=setGravity,
			setCfr=setCfr,
			lerpCfr=lerpCfr,
			setCamOffset=setCamOffset,
			setScale=setScale,
			getVel=getVel,
			getCamCF=getCamCF,
			isFirstPerson=isFirstPerson
		}
	end
	return {start=startreanimation,stop=stopreanimation}
]])()

local FDless = reanimation.start({
	accessorylimbs={

		{meshid="11263221350",textureid="11263219250",C0=CFrame.Angles(1.5707963267948966,0,1.5707963267948966),Name="Left Arm"},
		{meshid="11159370334",textureid="11159284657",C0=CFrame.Angles(-1.5707963267948966,0,1.5707963267948966),Name="Right Arm"},

		{meshid="14255522247",textureid="",C0=CFrame.Angles(1.5707963267948966,0,1.5707963267948966),Name="Left Arm"},
		{meshid="14255522247",textureid="",C0=CFrame.Angles(-1.5707963267948966,0,1.5707963267948966),Name="Right Arm"},

		{meshid="12344207333",textureid="",C0=CFrame.Angles(2,0,0),Name="Left Arm"},
		{meshid="12344206657",textureid="",C0=CFrame.Angles(2,0,0),Name="Right Arm"},
		
		{meshid="13831073174",textureid="",C0=CFrame.new(0.017,0,-0.23),CFrame.Angles(-1.4835298641951802,-0.15707963267948966,2.199114857512855),Name="Left Arm"},
		{meshid="13839903766",textureid="",C0=CFrame.new(0,-0.62,-0.01),CFrame.Angles(1.6580627893946132,0.15707963267948966,-2.199114857512855),Name="Right Arm"},

		{meshid="11159370334",textureid="11159285454",C0=CFrame.Angles(1.5707963267948966,0,1.5707963267948966),Name="Left Leg"},
		{meshid="12652772399",textureid="12652775021",C0=CFrame.new(0,-0.125,0),Name="Right Leg"},

		{meshid="14768684979",textureid="",C0=CFrame.Angles(0,0,1.5707963267948966),Name="Left Leg"},
		{meshid="14768684979",textureid="",C0=CFrame.Angles(0,0,1.5707963267948966),Name="Right Leg"},

		{meshid="14768666349",textureid="",C0=CFrame.identity,Name="Torso"},
		{meshid="14241018198",textureid="",C0=CFrame.identity,Name="Torso"},
		{meshid="13421774668",textureid="",C0=CFrame.identity,Name="Torso"},

		{meshid="4324138105",textureid="4324138210",C0=CFrame.Angles(-1.6144295580947547,1.5707963267948966,0)*CFrame.new(-0.125,0.3,0),Name="Left Arm"},
		{meshid="4154474745",textureid="4154474807",C0=CFrame.Angles(1.5271630954950384,-1.5707963267948966,0)*CFrame.new(-0.125,-0.3,0),Name="Left Arm"},
		{meshid="3030546036",textureid="3650191503",C0=CFrame.Angles(1.5271630954950384,1.5707963267948966,0)*CFrame.new(0.125,-0.3,0),Name="Right Arm"},
		{meshid="3030546036",textureid="3443321249",C0=CFrame.Angles(-1.6144295580947547,-1.5707963267948966,0)*CFrame.new(0.125,0.3,0),Name="Right Arm"},
		{meshid="3030546036",textureid="3360974849",C0=CFrame.Angles(1.5271630954950384,1.5707963267948966,0)*CFrame.new(-0.125,-0.35,0),Name="Left Leg"},
		{meshid="3030546036",textureid="3360978739",C0=CFrame.Angles(-1.6144295580947547,-1.5707963267948966,0)*CFrame.new(-0.125,0.3,0),Name="Left Leg"},
		{meshid="3030546036",textureid="3033898741",C0=CFrame.Angles(1.5271630954950384,-1.5707963267948966,0)*CFrame.new(0.125,-0.35,0),Name="Right Leg"},
		{meshid="3030546036",textureid="3409604993",C0=CFrame.Angles(-1.6144295580947547,1.5707963267948966,0)*CFrame.new(0.125,0.3,0),Name="Right Leg"},
		{meshid="17374767929",textureid="17374768001",C0=CFrame.Angles(1.57,0,1.57),Name="Right Leg"},
		{meshid="17374767929",textureid="17374768001",C0=CFrame.Angles(1.57,0,1.57),Name="Left Leg"},
		{meshid="14768684979",textureid="14768683674",C0=CFrame.Angles(1.57,0,1.57),Name="Right Leg"},
		{meshid="14768684979",textureid="14768683674",C0=CFrame.Angles(1.57,0,1.57),Name="Left Leg"},
		{meshid="4819720316",textureid="4819722776",C0=CFrame.Angles(0,0,0.2617993877991494),Name="Torso"}
	},
	camerasensitivity=1.25,
	allowshiftlock=true,
	ctrltp=false,
	placeholders=true,
	clickfling=false,
	highlightflingtargets=true,
	flingchangestate=true,
	respawntp=true,
	breakjointsmethod=1,
	setcharacter=false,
	charactertransparency=1,
	charactersize=1,
	defaultanimations=true,
	debug = {
		shownownerships=false,
		shownregions=false,
		addaccessories={}
	}
})

--Script start here dumbass

local script = game:GetObjects("rbxassetid://15828563411")[1].FakeMouseMainConversion


wait(1/100)
--for studio testing
--burbolizer/turbolizer idfk
--sans made this spaghetti coding
--salvo basically made the gui and wan reanimated some stuff along with adding effects to attacks kthx
----------------
--Salvo is trying to tweak
--also made gui
----------------------------
--ae sans works on this again why the f-
--bugetti spaghetti for some reason Godz is here
local player  = game:GetService("Players").LocalPlayer
local char = FDless.character
mouse = player:GetMouse()
Character = FDless.character
Humanoid = Character.Humanoid
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character['Right Arm']
LeftArm = Character['Left Arm']
RightLeg = Character['Right Leg']
LeftLeg = Character['Left Leg']
RightS = Torso['Right Shoulder']
RootJ = RootPart['RootJoint']
RootJoint = RootJ
LeftS = Torso['Left Shoulder']
RightH = Torso['Right Hip']
LeftH = Torso['Left Hip']
it=Instance.new
local attacking = false
vt=Vector3.new
cf=CFrame.new
local sne = 0
local chaeng = 1
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles

 rarm = RightArm
larm = LeftArm
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local hum = char.Humanoid
local ra = char["Right Arm"]
local la= char["Left Arm"]
local rl= char["Right Leg"]
local ll = char["Left Leg"]
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
------------------
local Chill = false
local sine = sne
-------------------------------------------------------
--Start Cret's variables stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Cret's variables stuff--
-------------------------------------------------------
local MoonEffect = script.Lunar
Player = player
MoonEffect.Parent = Player.PlayerGui
local MoonEffect2 = script.Effect2
MoonEffect2.Parent = Player.PlayerGui
local PyramidEffect = script.Pyramid
PyramidEffect.Parent = Player.PlayerGui
local Triangle1 = script.Triangle
Triangle1.Parent = Player.PlayerGui
local Triangle2 = script.Triangle2
Triangle2.Parent = Player.PlayerGui
local CrystalEff = script.Crystal
CrystalEff.Parent = Player.PlayerGui
local MAINCOLOR = BrickColor.new("Deep orange")
neckcf=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
neckcf2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LeftHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LeftHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RightHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RightHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootCF=euler(-1.57,0,3.14)
necko=neckcf
root = Character.HumanoidRootPart
RH,LH = RightH,LeftH
	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
	local SONG = 570332815
local gauntlet = script.Gauntlet2
local gauntlet2 = script.Gauntlet
gauntlet.Parent = char
gauntlet2.Parent = char
for i,v in pairs(gauntlet:GetChildren()) do
v.Anchored = false
end
for i,v in pairs(gauntlet2:GetChildren()) do
v.Anchored = false
end
local music = Instance.new("Sound",char.HumanoidRootPart)
music.SoundId = "rbxassetid://570332815"
music.Looped = true
music.Pitch = 1
music.Volume = 2
music.TimePosition = 0
music:Play()
	local HW = NewInstance('Weld',char,{Part0 = char["Right Arm"], Part1 = gauntlet2.Handle, C0 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)})
	local HWx = NewInstance('Weld',char,{Part0 = char["Left Arm"], Part1 = gauntlet.Handle, C0 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)})
local TurboCore = script.Core.Core
for i,v in pairs(script.Core.Core:GetChildren()) do
v.Anchored = false
end
Weld = Instance.new("Weld",script.Core.Core)
Weld.Part0 = script.Core.Core.Handle
Weld.Part1 = char.Torso
Weld.C0 = Weld.C0*CFrame.new(0,-0.25,0)
script.Core.Parent = Rig
local Speed = 18
local storedspeed = 18

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end


Debris = game:GetService("Debris")


--------------
local m = Instance.new("Model",char)
m.Name = MRANDOM(10,403583950)
--------------
local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,RightArm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,LeftArm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local luna = MoonEffect2:Clone()
luna.Anchored = true
luna.Parent = nil
luna.CanCollide = false
luna.Name = "LunaticEffect"

local basketball = script.Helkern
basketball.Parent = player.PlayerGui

function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end


function QuaternionFromCFrame2(cf)
    local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
    local trace = m00 + m11 + m22
    if trace > 0 then
        local s = math.sqrt(1 + trace)
        local recip = 0.5 / s
        return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
    else
        local i = 0
        if m11 > m00 then
            i = 1
        end
        if m22 > (i == 0 and m00 or m11) then
            i = 2
        end
        if i == 0 then
            local s = math.sqrt(m00 - m11 - m22 + 1)
            local recip = 0.5 / s
            return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
        elseif i == 1 then
            local s = math.sqrt(m11 - m22 - m00 + 1)
            local recip = 0.5 / s
            return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
        elseif i == 2 then
            local s = math.sqrt(m22 - m00 - m11 + 1)
            local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
        end
    end
end
 
function QuaternionToCFrame2(px, py, pz, x, y, z, w)
    local xs, ys, zs = x + x, y + y, z + z
    local wx, wy, wz = w * xs, w * ys, w * zs
    local xx = x * xs
    local xy = x * ys
    local xz = x * zs
    local yy = y * ys
    local yz = y * zs
    local zz = z * zs
    return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp2(a, b, t)
    local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
    local startInterp, finishInterp;
    if cosTheta >= 0.0001 then
        if (1 - cosTheta) > 0.0001 then
            local theta = ACOS(cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((1 - t) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = 1 - t
            finishInterp = t
        end
    else
        if (1 + cosTheta) > 0.0001 then
            local theta = ACOS(-cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((t - 1) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
    end
    return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
 
function clerp2(a, b, t)
    local qa = {QuaternionFromCFrame2(a)}
    local qb = {QuaternionFromCFrame2(b)}
    local ax, ay, az = a.x, a.y, a.z
    local bx, by, bz = b.x, b.y, b.z
    local _t = 1 - t
    return QuaternionToCFrame2(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp2(qa, qb, t))
end


local TextUI = script.TextUi
TextUI.Enabled = true
TextUI.Parent = char.Head
TextUI.Text.Image = "rbxassetid://2863687732"

local MainGui = script.Main
MainGui.Parent = player.PlayerGui
MainGui.ResetOnSpawn = false
MainGui.Enabled = false
local SideFrame_0 = Instance.new("Frame",MainGui)
SideFrame_0.Position = UDim2.new(0,0,0.671,0)
SideFrame_0.Size = UDim2.new(0,457,0,216)
SideFrame_0.BorderSizePixel = 4
SideFrame_0.BorderColor3 = BrickColor.new"White".Color
SideFrame_0.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame_0.Rotation = 0
--[[
local SideFrame_1 = Instance.new("Frame",basgui)
SideFrame_1.Position = UDim2.new(0.75,0,0.801,0)
SideFrame_1.Size = UDim2.new(0,457,0,216)
SideFrame_1.BorderSizePixel = 4
SideFrame_1.BorderColor3 = BrickColor.new"White".Color
SideFrame_1.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame_1.Rotation = 0]]--
local SideFrame0 = Instance.new("Frame",MainGui)
SideFrame0.Position = UDim2.new(0,0,0.731,0)
SideFrame0.Size = UDim2.new(0,457,0,216)
SideFrame0.BorderSizePixel = 4
SideFrame0.BorderColor3 = BrickColor.new"White".Color
SideFrame0.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame0.Rotation = 0
local SideFrame1 = Instance.new("Frame",MainGui)
SideFrame1.Position = UDim2.new(0,0,0.781,0)
SideFrame1.Size = UDim2.new(0,457,0,216)
SideFrame1.BorderSizePixel = 4
SideFrame1.BorderColor3 = BrickColor.new"White".Color
SideFrame1.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame1.Rotation = 0
local SideFrame2 = Instance.new("Frame",MainGui)
SideFrame2.Position = UDim2.new(0,0,0.831,0)
SideFrame2.Size = UDim2.new(0,457,0,216)
SideFrame2.BorderSizePixel = 4
SideFrame2.BorderColor3 = BrickColor.new"White".Color
SideFrame2.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame2.Rotation = 0
local SideFrame3 = Instance.new("Frame",MainGui) --0.75
SideFrame3.Position = UDim2.new(0,0,0.876,0)
SideFrame3.Size = UDim2.new(0,457,0,216)
SideFrame3.BorderSizePixel = 4
SideFrame3.BorderColor3 = BrickColor.new"White".Color
SideFrame3.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame3.Rotation = -180
local SideFrame4 = Instance.new("Frame",MainGui) --0.75
SideFrame4.Position = UDim2.new(0,0,0.921,0)
SideFrame4.Size = UDim2.new(0,457,0,216)
SideFrame4.BorderSizePixel = 4
SideFrame4.BorderColor3 = BrickColor.new"White".Color
SideFrame4.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame4.Rotation = -180
local SideFrame5 = Instance.new("Frame",MainGui) --0.75
SideFrame5.Position = UDim2.new(0,0,0.971,0)
SideFrame5.Size = UDim2.new(0,457,0,216)
SideFrame5.BorderSizePixel = 4
SideFrame5.BorderColor3 = BrickColor.new"White".Color
SideFrame5.BackgroundColor3 = BrickColor.new"Really black".Color
SideFrame5.Rotation = -180
local MainFrame = MainGui.MainFrame
local MainFrame2 = MainFrame.AAaa

if char:findFirstChild("Animate")then
char:findFirstChild("Animate"):Remove()
end

if Humanoid:findFirstChild("Animator")then
Humanoid:findFirstChild("Animator"):Remove()
end

ArtificiaLeftHB = Instance.new("BindableEvent", script)
ArtificiaLeftHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 
local Mode = "T"
LW=Torso["Left Shoulder"]
LH=Torso["Left Hip"]
RW=Torso["Right Shoulder"]
RH=Torso["Right Hip"]
RW.Name="Right Shoulder"
RW.Part0=char.Torso
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
RW.C1=cf(0, 0.5, 0)
RW.Part1=char["Right Arm"]
RW.Parent=char.Torso
--
LW.Name="Left Shoulder"
LW.Part0=char.Torso
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
LW.C1=cf(0, 0.5, 0)
LW.Part1=char["Left Arm"]
LW.Parent=char.Torso
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end 
--
local r = 255
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
	while wait() do
		for i = 0, 254/5 do
			swait()
			g = g + 5
		end
		for i = 0, 254/5 do
			swait()
			r = r - 5
		end
		for i = 0, 254/5 do
			swait()
			b = b + 5
		end
		for i = 0, 254/5 do
			swait()
			g = g - 5
		end
		for i = 0, 254/5 do
			swait()
			r = r + 5
		end
		for i = 0, 254/5 do
			swait()
			b = b - 5
		end
	end
end)) 
TurboArrow = script.SpeedArrow1
ToothpasteArrow = script.SpeedArrow2
ToothpasteArrow.Parent = Player.PlayerGui
TurboArrow.Parent = Player.PlayerGui



function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position
NoOutline(fp)
fp.Material="SmoothPlastic"
fp:BreakJoints()
return fp
end
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh)
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end
function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh)
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
function wind(type,pos,scale,value,speed,ahy)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = BrickColor.new("Institutional white")
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
	if ahy == false then
for i = 0,8,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.05
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
	else
		for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
		end
rng:Destroy()
end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
local glitchval = math.random(1,255)
if Mode == "R" then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if Mode == "R" then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

-- 
RW.Name="Right Shoulder"
RW.Part0=char.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=char["Right Arm"] 
RW.Parent=char.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=char.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=char["Left Arm"] 
LW.Parent=char.Torso
 
turboli = 0
turboli2 = 0
function sphere(bonuspeed, type, pos, scale, value, color)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r / 255, g / 255, b / 255)
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1 * value
elseif type == "Divide" then
scaler2 = 1 / value
end
coroutine.resume(coroutine.create(function()
for i = 0, 10 / bonuspeed, 0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r / 255, g / 255, b / 255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01 * value / bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01 / value * bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01 * bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
end
rng:Destroy()
end))
end
function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
if ModeOfGlitch ~= 9 then
rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
end
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function Wedge2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
if ModeOfGlitch ~= 9 then
rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
end
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Wedge"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000,GetClientProperty(kan,'PlaybackLoudness')/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
--[[
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		glitchval = math.random(1,255)
	end
end))]]--
local scaler2 = 0
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if Mode == "G" then
rng.Color = Color3.new(glitchval,glitchval,glitchval)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder + 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = color
rng.Color = color3
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Material = "Neon"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0
rng.TopSurface = 0
rng.BottomSurface = 0
rng.CFrame = pos
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end
FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
local Create = FELOADLIBRARY.Create
CFuncs = {
Part = {
Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
local Part = Create("Part")({
Parent = Parent,
Reflectance = Reflectance,
Transparency = Transparency,
CanCollide = false,
Locked = true,
BrickColor = BrickColor.new(tostring(BColor)),
Name = Name,
Size = Size,
Material = Material
})
RemoveOutlines(Part)
return Part
end
},
Mesh = {
Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh)({
Parent = Part,
Offset = OffSet,
Scale = Scale
})
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
},
Mesh = {
Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
local Msh = Create(Mesh)({
Parent = Part,
Offset = OffSet,
Scale = Scale
})
if Mesh == "SpecialMesh" then
Msh.MeshType = MeshType
Msh.MeshId = MeshId
end
return Msh
end
},
Weld = {
Create = function(Parent, Part0, Part1, C0, C1)
local Weld = Create("Weld")({
Parent = Parent,
Part0 = Part0,
Part1 = Part1,
C0 = C0,
C1 = C1
})
return Weld
end
},
Sound = {
Create = function(id, par, vol, pit)
coroutine.resume(coroutine.create(function()
local S = Create("Sound")({
Volume = vol,
Pitch = pit or 1,
SoundId = id,
Parent = par or workspace
})
wait()
S:play()
game:GetService("Debris"):AddItem(S, 10)
end))
end
},

["TimeSound"] = {
Create = function(id, par, vol, pit, timepos) 
coroutine.resume(coroutine.create(function()
local S = Create("Sound"){
Volume = vol,
Name = "EffectSoundo",
Pitch = pit or 1,
SoundId = id,
TimePosition = timepos,
Parent = par or workspace,
}
wait() 
S:play() 
game:GetService("Debris"):AddItem(S, 10)
end))
end;
};
["EchoSound"] = {
Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
coroutine.resume(coroutine.create(function()
local Sas = Create("Sound"){
Volume = vol,
Name = "EffectSoundo",
Pitch = pit or 1,
SoundId = id,
TimePosition = timepos,
Parent = par or workspace,
}
local E = Create("EchoSoundEffect"){
Delay = echodelay,
Name = "Echo",
Feedback = fedb,
DryLevel = dryl,
Parent = Sas,
}
wait() 
Sas:play() 
game:GetService("Debris"):AddItem(Sas, delays)
end))
end;
};
LongSound = {
Create = function(id, par, vol, pit)
coroutine.resume(coroutine.create(function()
local S = Create("Sound")({
Volume = vol,
Pitch = pit or 1,
SoundId = id,
Parent = par or workspace
})
wait()
S:play()
game:GetService("Debris"):AddItem(S, 30)
end))
end
},
ParticleEmitter = {
Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
local fp = Create("ParticleEmitter")({
Parent = Parent,
Color = ColorSequence.new(Color1, Color2),
LightEmission = LightEmission,
Size = Size,
Texture = Texture,
Transparency = Transparency,
ZOffset = ZOffset,
Acceleration = Accel,
Drag = Drag,
LockedToPart = LockedToPart,
VelocityInheritance = VelocityInheritance,
EmissionDirection = EmissionDirection,
Enabled = Enabled,
Lifetime = LifeTime,
Rate = Rate,
Rotation = Rotation,
RotSpeed = RotSpeed,
Speed = Speed,
VelocitySpread = VelocitySpread
})
return fp
end
},
CreateTemplate = {}
}
function waveEff(bonuspeed,type,typeoftrans,pos,scale,value,value2,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
rngm.MeshId = "rbxassetid://20329976"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
end
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(5*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-5*bonuspeed/2),0)
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end

function dmg(dude)
	local keptcolor = MAINCOLOR
if dude.Name ~= Character then
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("BasePart") or v:IsA("MeshPart") then
v.Name = "DEMINISHED"
CFuncs["Sound"].Create("rbxassetid://763718160", v, 0.75, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", v, 1, 1)
--[[for i = 0, 1 do
sphere2(1,"Add",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,10,-0.01,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
end]]--
end
end
wait(0.5)
targetted = nil
CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.25, 0.285)
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("BasePart") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
v.Anchored = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 0.75
bld.Texture = "rbxassetid://2273224484" ---284205403
bld.Color = ColorSequence.new(keptcolor.Color)
bld.Rate = 15
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(2,5)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
v.Color = keptcolor.Color
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v:BreakJoints()
v.Transparency = v.Transparency + 0.02
end
v:BreakJoints()
for i = 0, 4 do
slash(math.random(10,50)/10,3,true,"Round","Add","Out",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.0025,0.01),math.random(10,100)/2500,BrickColor.new("White"))
end
block(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,keptcolor,keptcolor.Color)
CFuncs["Sound"].Create("rbxassetid://782353117", v, 0.25, 1.2)
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.5, 0.75)
bld.Speed = NumberRange.new(10,25)
bld.Drag = 5
bld.Acceleration = vt(0,2,0)
wait(0.5)
bld.Enabled = false
wait(4)
coroutine.resume(coroutine.create(function()
for i = 0, 99 do
swait()
v:Destroy()
dude:Destroy()
end
end))
end))
end))
end
end
end))
end)
ds()
end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end



--        RAGDOLL STUFF

 
function recurse(root,callback,i)
    i= i or 0
    for _,v in pairs(root:GetChildren()) do
        i = i + 1
        callback(i,v)
       
        if #v:GetChildren() > 0 then
            i = recurse(v,callback,i)
        end
    end
   
    return i
end
 
function ragdollJoint(character, part0, part1, attachmentName, className, properties)
    attachmentName = attachmentName.."RigAttachment"
    local constraint = Instance.new(className.."Constraint")
    constraint.Attachment0 = part0:FindFirstChild(attachmentName)
    constraint.Attachment1 = part1:FindFirstChild(attachmentName)
    constraint.Name = "RagdollConstraint"..part1.Name
   
    for _,propertyData in next,properties or {} do
        constraint[propertyData[1]] = propertyData[2]
    end
   
    constraint.Parent = character
end
 
function getAttachment0(character, attachmentName)
    for _,child in next,character:GetChildren() do
        local attachment = child:FindFirstChild(attachmentName)
        if attachment then
            return attachment
        end
    end
end
 
function ArtificialHitbox(Part)
    local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
    HITBOX.CanCollide = true
    HITBOX.CFrame = Part.CFrame
    weldBetween(Part,HITBOX)
end
 
function R15Ragdoll(character,KeepArms)
    character:BreakJoints()
    coroutine.resume(coroutine.create(function()
        recurse(character, function(_,v)
            if v:IsA("Attachment") then
                v.Axis = Vector3.new(0, 1, 0)
                v.SecondaryAxis = Vector3.new(0, 0, 1)
                v.Rotation = Vector3.new(0, 0, 0)
            end
        end)
        for _,child in next,character:GetChildren() do
            if child:IsA("Accoutrement") then
                for _,part in next,child:GetChildren() do
                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                        local attachment1 = part:FindFirstChildOfClass("Attachment")
                        local attachment0 = getAttachment0(character,attachment1.Name)
                        if attachment0 and attachment1 then
                            local constraint = Instance.new("HingeConstraint")
                            constraint.Attachment0 = attachment0
                            constraint.Attachment1 = attachment1
                            constraint.LimitsEnabled = true
                            constraint.UpperAngle = 0
                            constraint.LowerAngle = 0
                            constraint.Parent = character
                        end
                        ArtificialHitbox(part)
                    elseif part.Name == "HumanoidRootPart" then
                        part:remove()
                    end
                end
            end
        end
       
        ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
            {"LimitsEnabled",true};
            {"UpperAngle",5};
        })
        if character:FindFirstChild("Head") then
            ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
                {"LimitsEnabled",true};
                {"UpperAngle",15};
            })
        end
       
        local handProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle",0};
            {"LowerAngle",0};
        }
        ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
        ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)
       
        local shinProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle", 0};
            {"LowerAngle", -75};
        }
        ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
        ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)
       
        local footProperties = {
            {"LimitsEnabled", true};
            {"UpperAngle", 15};
            {"LowerAngle", -45};
        }
        ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
        ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
        if KeepArms == true then
            ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
            ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
            ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
            ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
        end
        ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
        ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
        Debris:AddItem(character,50)
    end))
end
 
function Ragdoll(Character2,CharTorso,KeepArms)
    coroutine.resume(coroutine.create(function()
        Character2:BreakJoints()
        local hum = Character2:findFirstChild("Humanoid")
        hum:remove()
        local function Scan(ch)
            local e
            for e = 1,#ch do
                Scan(ch[e]:GetChildren())
                if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
                    ch[e]:remove()
                end
            end
        end
        local NEWHUM = IT("Humanoid")
        NEWHUM.Name = "Corpse"
        NEWHUM.Health = 0
        NEWHUM.MaxHealth = 0
        NEWHUM.PlatformStand = true
        NEWHUM.Parent = Character2
        NEWHUM.DisplayDistanceType = "None"
   
        local ch = Character2:GetChildren()
        local i
        for i = 1,#ch do
            if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
                ch[i]:remove()
            end
        end
   
        local Torso2 = Character2.Torso
        local movevector = Vector3.new()
   
        if Torso2 then
            movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
            local Head = Character2:FindFirstChild("Head")
            if Head then
                local Neck = Instance.new("Weld")
                Neck.Name = "Neck"
                Neck.Part0 = Torso2
                Neck.Part1 = Head
                Neck.C0 = CFrame.new(0, 1.5, 0)
                Neck.C1 = CFrame.new()
                Neck.Parent = Torso2
   
            end
            local Limb = Character2:FindFirstChild("Right Arm")
            if Limb and KeepArms == true then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "RightShoulder"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Left Arm")
            if Limb and KeepArms == true then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "LeftShoulder"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Right Leg")
            if Limb then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "RightHip"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            local Limb = Character2:FindFirstChild("Left Leg")
            if Limb then
   
                Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
                local Joint = Instance.new("Glue")
                Joint.Name = "LeftHip"
                Joint.Part0 = Torso2
                Joint.Part1 = Limb
                Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
                Joint.Parent = Torso2
   
                local B = Instance.new("Part")
                B.TopSurface = 0
                B.BottomSurface = 0
                B.formFactor = "Symmetric"
                B.Size = Vector3.new(1, 1, 1)
                B.Transparency = 1
                B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
                B.Parent = Character2
                local W = Instance.new("Weld")
                W.Part0 = Limb
                W.Part1 = B
                W.C0 = CFrame.new(0, -0.5, 0)
                W.Parent = Limb
   
            end
            --[
            local Bar = Instance.new("Part")
            Bar.TopSurface = 0
            Bar.BottomSurface = 0
            Bar.formFactor = "Symmetric"
            Bar.Size = Vector3.new(1, 1, 1)
            Bar.Transparency = 1
            Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
            Bar.Parent = Character2
            local Weld = Instance.new("Weld")
            Weld.Part0 = Torso2
            Weld.Part1 = Bar
            Weld.C0 = CFrame.new(0, 0.5, 0)
            Weld.Parent = Torso2
            --]]
        end
        Character2.Parent = workspace
        Debris:AddItem(Character2,50)
   
        return Character2,Torso2
    end))
end


function Freeze(CHARACTER,LAST)
		local q = CHARACTER:GetChildren()
		for i = 1, #q do
			local bob = q[i]
			if bob.ClassName == "Part" or bob.ClassName == "MeshPart" then
				if bob.Transparency < 1 then
					bob.Anchored = true
					if bob:FindFirstChild("Ice") == nil then
					local icelayer = bob:Clone()
					icelayer.Parent = bob
					icelayer.Material = "Ice"
					icelayer.CanCollide = false
					icelayer.BrickColor = BRICKC"Steel blue"
					icelayer.Transparency = 0.5
					icelayer.CFrame = bob.CFrame
					icelayer.Name = "Ice"
					icelayer.Size = icelayer.Size + VT(0.1,0.1,0.1)
					if icelayer:FindFirstChildOfClass("Decal") then
						icelayer:FindFirstChildOfClass("Decal"):remove()
					end
					end
				end
			end
		end
		coroutine.resume(coroutine.create(function()
			swait(LAST*100)
			local q = CHARACTER:GetChildren()
			for i = 1, #q do
				local bob = q[i]
				if bob.ClassName == "Part" or bob.ClassName == "MeshPart" then
					if bob.Transparency < 1 then
						bob.Anchored = false
						bob.Ice:remove()
					end
				end
			end
		end))
end


function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)

end
function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function CrystalEffect(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,outerpos)
local type = type
local rng = CrystalEff:Clone()
		rng.Parent = char
        rng.Anchored = true
        rng.CanCollide = false
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(x1, y1, z1)
        rng.Transparency = 0.25
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + Vector3.new(0,0.05,0)
rng.Transparency = rng.Transparency + 0.01*bonuspeed
end
rng:Destroy()
end))
end



function TriangleEffect(bonuspeed,FastSpeed,type,pos,value,outerpos)
local type = type
local rng = Triangle2:Clone()
		rng.Parent = char
        rng.Anchored = true
        rng.CanCollide = false
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Transparency = 0.32
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + Vector3.new(0,0.05,0)
rng.Transparency = rng.Transparency + 0.01*bonuspeed
end
rng:Destroy()
end))
end

function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function ShowDamage(Pos, Text, Time, Color)
coroutine.resume(coroutine.create(function()
  local Rate = 0.03333333333333333
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(Character, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  EffectPart.CFrame = CFrame.new(Pos)
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(6, 0, 6, 0),
    Adornee = EffectPart,
    Parent = EffectPart,
	AlwaysOnTop=true,
	Active=true
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(1, 0, 1, 0),
    Text = Text,
    TextColor3 = MAINCOLOR.Color,
   	TextStrokeColor3 = Color3.new(0,0,0),
	TextStrokeTransparency=0,
    TextScaled = true,
    Font = "Arcade",
    Parent = BillboardGui,
	ZIndex=4,
  })
local raise=.2
local rot=math.random(-10,10)/15
local aaa=math.random(-360,360)
local bbb=math.random(-360,360)
for aaa=0,2,.01 do
swait()
raise=raise-.008
if Mode == "R" then
	TextLabel.TextColor3 = C3(r/255,g/255,b/255)
end
TextLabel.Rotation = TextLabel.Rotation+rot
TextLabel.TextTransparency=aaa
TextLabel.TextStrokeTransparency=aaa
EffectPart.Position=EffectPart.Position+Vector3.new(0,raise,0)
end
wait(3)
BillboardGui:Remove()
EffectPart:Remove()
end))
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end

function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
	--MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end
function FindNearestTorso(pos,distance)
local list=(workspace:children())
local torso=nil
local dist=distance
local temp,human,temp2=nil,nil,nil
for x=1,#list do
temp2=list[x]
if temp2.className=="Model"and temp2.Name~=char.Name then
temp=temp2:findFirstChild("Torso")
human=temp2:findFirstChildOfClass("Humanoid")
if temp~=nil and human~=nil and human.Health>=0 and (temp.Position-pos).magnitude<dist then
local dohit=true
if dohit==true then
torso=temp
dist=(temp.Position-pos).magnitude
end
end
end
end
return torso,dist
end

function LunarAttack()
attacking = true
Speed = 0
CFuncs["Sound"].Create("rbxassetid://1368583274", larm, 4.5, 1.625)
local OverCut = false
for i = 0, 4, 0.1 do
swait()
MagniDamage(Torso, 13, 2,6, 0, "Normal",153092213)
--slash(math.random(10,30)/10,5,true,"Round","Add","Out",x.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.001,0.1),math.random(50,400)/420,BrickColor.new("White"))
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
slash(math.random(20,40)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.025,0.001,0.025),-0.025,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(5),math.rad(-50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-170),math.rad(-10),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(20),math.rad(40),math.rad(-20)),.3)
end
local orb = basketball:Clone()
orb.Parent = Character
orb.Name = "basketball"
orb.Torso.CFrame = root.CFrame*CFrame.new(0,7,0)--50,0)
local x = orb.Torso
local keptcolor = MAINCOLOR
local poste = 0
local rotation = 0
local upperpos = 0
local rate = 0
for i,v in pairs(orb:GetChildren()) do
	if v:IsA("BasePart") then
v.Anchored = true
v.CanCollide = false
v.Transparency = 0
end
end
OverCut = true
for i = 0, 6 do
--slash(math.random(10,30)/10,5,true,"Round","Add","Out",x.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.001,0.1),math.random(50,400)/420,BrickColor.new("White"))
end
--sphere2(2,"Add",x.CFrame,vt(10,10,10),0.5,0.5,0.5,BrickColor.new("Bright yellow"),BrickColor.new("Bright yellow").Color)
--sphere2(3,"Add",x.CFrame,vt(10,10,10),0.75,0.75,0.75,BrickColor.new("Bright yellow"),BrickColor.new("Bright yellow").Color)
--sphere2(4,"Add",x.CFrame,vt(10,10,10),1,1,1,BrickColor.new("Bright yellow"),BrickColor.new("Bright yellow").Color)
CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 7.5, 1)
local a = Instance.new("Part",workspace)
a.Name = "Direction"	
a.Anchored = true
a.Transparency = 1
a.CanCollide = false
local ray = Ray.new(
x.CFrame.p,                           -- origin
(mouse.Hit.p - x.CFrame.p).unit * 500 -- direction
) 
local ignore = x
local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
a.BottomSurface = 10
a.TopSurface = 10
local distance = (x.CFrame.p - position).magnitude
a.Size = Vector3.new(0.1, 0.1, 0.1)
a.CFrame = CFrame.new(x.CFrame.p, position) * CFrame.new(0, 0, 0)
x.CFrame = a.CFrame
for i = 0, 2, 0.1 do
swait()
--sphere2(5,"Add",x.CFrame*CFrame.new(math.random(-20,20),math.random(-20,20),math.random(-20,20)),vt(1,1,1),0.01,0.01,0.01,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
ray = Ray.new(
x.CFrame.p,                           -- origin
(mouse.Hit.p - x.CFrame.p).unit * 500 -- direction
) 
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (x.CFrame.p - position).magnitude
a.CFrame = CFrame.new(x.CFrame.p, position) * CFrame.new(0, 0, 0)
x.CFrame = a.CFrame
--slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-100),math.rad(-0),math.rad(110)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(1),math.rad(11),math.rad(12)),.3)
end
swait(30)
x.CFrame = a.CFrame
for i,v in pairs(orb:GetChildren()) do
	if v:IsA("BasePart") then
v.Anchored = false
end
end
a:Destroy()
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = x.CFrame.lookVector*100
bv.Parent = x
local hitted = false
CFuncs["Sound"].Create("rbxassetid://466493476", orb, 7.5, 0.7)
x.CFrame = x.CFrame * CFrame.Angles(0,math.rad(360*math.cos(sne/6)),0)
--waveEff(2,"Add","Out",x.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(5,1,5),0.5,0.1,BrickColor.new("Bright yellow"))
--waveEff(4,"Add","Out",x.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(5,1,5),0.5,0.05,BrickColor.new("Bright blue"))
coroutine.resume(coroutine.create(function()
while true do
swait(2)
if hitted == false and x.Parent ~= nil then
	MagniDamage(x, 5, 3,6, 0, "Normal",153092213)
	--orb.CFrame = orb.CFrame * CFrame.Angles(math.rad(360*math.cos(sne/6)),0,0)
--slash(3,5,true,"Round","Add","Out",x.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.075,0.005,0.075),-0.05,BrickColor.new("White"))
elseif hitted == true and x.Parent == nil then
break
end
end
end))
--[[x.Touched:connect(function(hit) 
if hitted == false and hit.Parent ~= char then
hitted = true
MagniDamage(x, 67, 23,32, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://763717897", x, 10, 1)
CFuncs["Sound"].Create("rbxassetid://1295446488", x, 9, 0.75)
for i = 0, 24 do
slash(math.random(15,30)/10,5,true,"Round","Add","Out",x.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),math.random(125,250)/350,BrickColor.new("White"))
end
slash(1,5,true,"Round","Add","Out",x.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.01,0.015,0.01),2.5,BrickColor.new("White"))
slash(1,5,true,"Round","Add","Out",x.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.01,0.01,0.01),3,BrickColor.new("White"))
sphere2(1,"Add",x.CFrame,vt(15,15,15),2,2,2,BrickColor.new("New Yeller"),BrickColor.new("New Yeller").Color)
sphere2(1.5,"Add",x.CFrame,vt(15,10,15),2.1,2.1,2.1,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
sphere2(2,"Add",x.CFrame,vt(15,15,15),2.2,2.2,2.2,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
for i,v in pairs(orb:GetChildren()) do
	if v:IsA("BasePart") then
v.Anchored = true
v.Transparency = 1
end
end
coroutine.resume(coroutine.create(function()
for i = 0, 4, 0.1 do
swait()
--slash(math.random(10,50)/10,5,true,"Round","Add","Out",x.CFrame*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.015,0.01),1.5,BrickColor.new("Bright blue"))
end
end))
wait(10)
orb:Remove()()
end
end)]]--
game:GetService("Debris"):AddItem(orb, 20)
for i = 0, 1, 0.1 do
swait()
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.4,0)*angles(math.rad(0),math.rad(0),math.rad(-70)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(70)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-40),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-80)),.3)
end
attacking = false
Speed = 43
end

function LunarAttackA()
attacking = true
Speed = 0
CFuncs["Sound"].Create("rbxassetid://1368583274", larm, 4.5, 1.2)
local OverCut = false
for i = 0, 10, 0.1 do
swait()
MagniDamage(Torso, 12, 2,5, 0, "Normal",153092213)
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
slash(math.random(20,40)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-1.5,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.025,0.001,0.025),-0.025,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(50)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15),math.rad(5),math.rad(-50)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-170),math.rad(-10),math.rad(0)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(20),math.rad(40),math.rad(-20)),.3)
end
OverCut = true
local orb = MoonEffect:Clone()
orb.Anchored = true
orb.Parent = Character
orb.CanCollide = false
orb.Name = "Orbieee"
orb.CFrame = root.CFrame*CFrame.new(0,50,0)
for i = 0, 24 do
slash(math.random(10,30)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.001,0.1),math.random(50,400)/420,BrickColor.new("White"))
end
sphere2(2,"Add",orb.CFrame,vt(10,10,10),0.5,0.5,0.5,BrickColor.new("Bright yellow"),BrickColor.new("Bright yellow").Color)
sphere2(3,"Add",orb.CFrame,vt(10,10,10),0.75,0.75,0.75,BrickColor.new("Bright yellow"),BrickColor.new("Bright yellow").Color)
sphere2(4,"Add",orb.CFrame,vt(10,10,10),1,1,1,BrickColor.new("Bright yellow"),BrickColor.new("Bright yellow").Color)
CFuncs["Sound"].Create("rbxassetid://1368637781", orb, 7.5, 1)
local a = Instance.new("Part",workspace)
a.Name = "Direction"	
a.Anchored = true
a.Transparency = 1
a.CanCollide = false
local ray = Ray.new(
orb.CFrame.p,                           -- origin
(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
) 
local ignore = orb
local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
a.BottomSurface = 10
a.TopSurface = 10
local distance = (orb.CFrame.p - position).magnitude
a.Size = Vector3.new(0.1, 0.1, 0.1)
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
orb.CFrame = a.CFrame
for i = 0, 8, 0.1 do
swait()
sphere2(5,"Add",orb.CFrame*CFrame.new(math.random(-20,20),math.random(-20,20),math.random(-20,20)),vt(1,1,1),0.01,0.01,0.01,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
ray = Ray.new(
orb.CFrame.p,                           -- origin
(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
) 
hit, position, normal = workspace:FindPartOnRay(ray, ignore)
distance = (orb.CFrame.p - position).magnitude
a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
orb.CFrame = a.CFrame
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(40),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(60)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(-60)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-100),math.rad(-0),math.rad(110)),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(1),math.rad(11),math.rad(12)),.3)
end
orb.Anchored = false
a:Destroy()
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = orb.CFrame.lookVector*150
bv.Parent = orb
local hitted = false
CFuncs["Sound"].Create("rbxassetid://466493476", orb, 7.5, 0.7)
orb.CFrame = orb.CFrame * CFrame.Angles(0,math.rad(360*math.cos(sne/6)),0)
waveEff(2,"Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(5,1,5),0.5,0.1,BrickColor.new("Bright yellow"))
waveEff(4,"Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(5,1,5),0.5,0.05,BrickColor.new("Bright blue"))
coroutine.resume(coroutine.create(function()
while true do
swait(2)
if hitted == false and orb.Parent ~= nil then
	--orb.CFrame = orb.CFrame * CFrame.Angles(math.rad(360*math.cos(sne/6)),0,0)
slash(3,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.075,0.005,0.075),-0.05,BrickColor.new("White"))
elseif hitted == true and orb.Parent == nil then
break
end
end
end))
orb.Touched:connect(function(hit) 
if hitted == false and hit.Parent ~= char then
hitted = true
MagniDamage(orb, 67, 72,115, 0, "Normal",153092213)
CFuncs["Sound"].Create("rbxassetid://763717897", orb, 10, 1)
CFuncs["Sound"].Create("rbxassetid://1295446488", orb, 9, 0.75)
for i = 0, 24 do
slash(math.random(15,30)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),math.random(125,250)/350,BrickColor.new("White"))
end
slash(1,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.01,0.015,0.01),2.5,BrickColor.new("White"))
slash(1,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90),math.rad(math.random(-360,360)),0),vt(0.01,0.01,0.01),3,BrickColor.new("White"))
sphere2(1,"Add",orb.CFrame,vt(15,15,15),2,2,2,BrickColor.new("New Yeller"),BrickColor.new("New Yeller").Color)
sphere2(1.5,"Add",orb.CFrame,vt(15,10,15),2.1,2.1,2.1,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
sphere2(2,"Add",orb.CFrame,vt(15,15,15),2.2,2.2,2.2,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
orb.Anchored = true
orb.Transparency = 1
coroutine.resume(coroutine.create(function()
for i = 0, 4, 0.1 do
swait()
--slash(math.random(10,50)/10,5,true,"Round","Add","Out",orb.CFrame*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.015,0.01),1.5,BrickColor.new("Bright blue"))
end
end))
wait(10)
orb:Destroy()
end
end)
game:GetService("Debris"):AddItem(orb, 10)
for i = 0, 2, 0.1 do
swait()
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.05,0.01,0.05),math.random(25,50)/250,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0),math.rad(-6)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(30),math.rad(3)),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.4,0)*angles(math.rad(0),math.rad(0),math.rad(-70)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5),math.rad(0),math.rad(70)),.3)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-13),math.rad(-40),math.rad(20)),.3)
LW.C0=clerp(LW.C0,cf(-1.45,0.5,0.1)*angles(math.rad(90),math.rad(0),math.rad(-80)),.3)
end
attacking = false
Speed = 43
end

function glitchattack()
	attacking = true
	local brickglitch = {BrickColor.new("Institutional white"),BrickColor.new("Really black")}
local keptcolor = brickglitch[MRANDOM(1,2)]
local glitchvalA = math.random(0,255)
CFuncs["Sound"].Create("rbxassetid://1208650519", char, 10, 1)
for i = 0, 8, 0.1 do
		swait()
		sphereMK(3.5,-1,"Add",sorb.CFrame* CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),0.5,0.5,10,-0.005,BrickColor.new("Institutional white"),0)	
				RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 - 2 * math.cos(sne / 32))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 + 2 * math.cos(sne / 32))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0 + 0.02 * math.cos(sne / 32),-0.1 + 0.05 * math.cos(sne / 32))*angles(math.rad(0 - 2 * math.cos(sne / 32)),math.rad(0),math.rad(-11)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(-2 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(10 - 2.5 * math.cos(sne / 28)),math.rad(0),math.rad(-31 + 6.5 * math.cos(sne / 32.5))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(math.random(161,176)),math.rad(-5),math.rad(15 + 7.5 * math.cos(sne / 32.5))),.1)
LW.C0=clerp(LW.C0,cf(-1.5+0.05*math.cos(sne/32),0.65-.05*math.cos(sne/32),0)*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(math.random(136,159)),math.rad(5),math.rad(29 - 8.5 * math.cos(sne / 32.5))),.1)
end
for i = 0, 3.1, 0.1 do
		swait()
		sphereMK(3.5,-1,"Add",sorb.CFrame* CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),0.5,0.5,10,-0.005,BrickColor.new("Institutional white"),0)	
RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 - 2 * math.cos(sne / 32))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 + 2 * math.cos(sne / 32))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0 + 0.02 * math.cos(sne / 32),-0.1 + 0.05 * math.cos(sne / 32))*angles(math.rad(0 - 2 * math.cos(sne / 32)),math.rad(0),math.rad(-51)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(-2 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(10 - 2.5 * math.cos(sne / 28)),math.rad(0),math.rad(-71 + 6.5 * math.cos(sne / 32.5))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(math.random(81,108)),math.rad(-5),math.rad(89 + 7.5 * math.cos(sne / 32.5))),.1)
LW.C0=clerp(LW.C0,cf(-1.5+0.05*math.cos(sne/32),0.65-.05*math.cos(sne/32),0)*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(math.random(136,159)),math.rad(5),math.rad(29 - 8.5 * math.cos(sne / 32.5))),.1)
end
for i = 0, MRANDOM(18,23) do
		PixelBlockNeg(1,math.random(1,3),"Add",mouse.Hit*CFrame.new(math.random(-26,26),0,math.random(-26,26))*CFrame.Angles(math.rad(90 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),5,5,5,0.1,keptcolor,-10)
end
for i, v in pairs(FindNearestHead(mouse.Hit.p, 36)) do
if v:FindFirstChild('Head') then
coroutine.resume(coroutine.create(function()
CFuncs["Sound"].Create("rbxassetid://1042716828", v.Head, 5, 0.5)
local vel = Instance.new("BodyPosition", v.Head)
vel.P = 12500
vel.D = 1000
vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
vel.position = v.Head.CFrame.p + vt(0,10,0)
for i,v in pairs(v:GetChildren()) do
if v:IsA("BasePart") or v:IsA("MeshPart") then
coroutine.resume(coroutine.create(function()
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 0.75
bld.Texture = "rbxassetid://363275192" ---284205403
bld.Color = ColorSequence.new(Color3.new(glitchvalA,glitchvalA,glitchvalA))
bld.Rate = 1
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(2,5)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
end))
end
end
local BasePlate = game.Workspace:FindFirstChild("Baseplate") or game.Workspace:FindFirstChild("Base")
local A1 = Instance.new("Attachment",BasePlate)
local A2 = Instance.new("Attachment",v.Head)
local Beem = Instance.new("Beam",v.Head)
Beem.Attachment0 = A1
Beem.Attachment1 = A2
Beem.LightEmission = 1
Beem.FaceCamera = true
Beem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 0)})
Beem.Width0 = 1
Beem.Width1 = 1
Beem.Texture = "rbxassetid://1134824633"
Beem.TextureMode = "Wrap"
Beem.TextureLength = 2
Beem.TextureSpeed = 5
Beem.Color = ColorSequence.new(keptcolor.Color)
wait(5)
coroutine.resume(coroutine.create(function()
local ref = Instance.new("Part", char)
ref.Anchored = true
ref.CanCollide = false
ref.Transparency = 1
ref.CFrame = v.Head.CFrame
for i = 0, 9 do
slash(math.random(10,25)/10,5,true,"Round","Add","Out",v.Head.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.5,0.001,0.5),-1,BrickColor.new("Really black"))
end
v.Head.Parent:Destroy()
CFuncs["Sound"].Create("rbxassetid://763718160", ref, 2, 1.1)
CFuncs["Sound"].Create("rbxassetid://782353443", ref, 2, 1)
CFuncs["Sound"].Create("rbxassetid://335657174", ref, 2, 1)
swait(120)
Beem:Remove()
ref:Destroy()
ref:Remove()
end))
end))
end
end
CFuncs["Sound"].Create("rbxassetid://1664711478", char, 2, 1)
CFuncs["Sound"].Create("rbxassetid://1177785010", char, 1, 1)
CFuncs["Sound"].Create("rbxassetid://167115397", char, 1, 0.6)
CFuncs["Sound"].Create("rbxassetid://782353443", char, 1, 0.9)
CFuncs["Sound"].Create("rbxassetid://782353443", char, 2, 0.8)
CFuncs["Sound"].Create("rbxassetid://782353443", char, 2, 0.7)
	attacking = false
end


function Daash()
	attacking = true
	Speed = 0
	for i = 0,1,0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(-20),math.rad(30)),.5)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.75)*angles(math.rad(30),math.rad(0),math.rad(20)),.5)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(-20)),.5)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(40),math.rad(-8),math.rad(-10)),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-30)),.5)
end
CFuncs["Sound"].Create("rbxassetid://763716870", root, 8,1)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 10,0.5)
CFuncs["Sound"].Create("rbxassetid://782225570", root, 9,0.8)
CFuncs["Sound"].Create("rbxassetid://763717569", root, 8,0.9)
for i = 0,6,0.1 do
swait()
root.CFrame = root.CFrame + root.CFrame.lookVector*6
coroutine.resume(coroutine.create(function()
local turbo4 = ToothpasteArrow:Clone()
turbo4.Material = Enum.Material.Glass
turbo4.Parent = char
turbo4.Anchored = true
turbo4.CanCollide = false
turbo4.CFrame = RootPart.CFrame*cf(0,1.5,2.65)*angles(math.rad(146),math.rad(-180),math.rad(90))
turbo4.Transparency = 0
swait(120)
repeat
turbo4.Transparency = turbo4.Transparency + 0.01
swait()
until turbo4.Transparency == 0 or turbo4.Transparency > 0.99
game:GetService("Debris"):AddItem(turbo4, 4)
end))
	local dis2 = CreateParta(char,0.25,1,"Neon",BrickColor.new("Toothpaste"))
CreateMesh(dis2,"Sphere",1,1,1)
dis2.Anchored = true
dis2.CFrame = RightArm.CFrame*CFrame.new(0,-3,0)
sphere2(5,"Add",dis2.CFrame,vt(1,1,1),0.1,0.1,0.1,dis2.BrickColor,dis2.Color)
coroutine.resume(coroutine.create(function()
		dis2.Transparency = 1
	swait(5)
	dis2.Transparency = 1
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",dis2)
eff.Texture = "rbxassetid://2273224484"
eff.LightEmission = 1
eff.Color = ColorSequence.new(dis2.Color)
eff.Rate = 4
eff.Lifetime = NumberRange.new(0.5,2)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,20,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(50,450)
eff.Drag = 2
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-50,50)
local eff2 = eff:Clone()
eff2.Parent = dis2
eff2.LightEmission = 0
eff2.Color = ColorSequence.new(dis2.Color)
wait(0.25)
eff.Enabled = false
eff2.Enabled = false
end))
--	CFuncs["Sound"].Create("rbxassetid://782353117", dis2, 1,0.75)
--	CFuncs["Sound"].Create("rbxassetid://1666361078", dis2, 1,1.25)
--	CFuncs["Sound"].Create("rbxassetid://782353443", dis2, 2,1.15)
end))
for i, v in pairs(FindNearestHead(Torso.CFrame.p, 5)) do
if v:FindFirstChild('Head') then
dmg(v)
end
end
game:GetService("Debris"):AddItem(dis2, 4.5)
waveEff(5,"Add","In",RightLeg.CFrame*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(5,0.25,1),-0.075,0.05,BrickColor.new("White"))
waveEff(5,"Add","In",LeftLeg.CFrame*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(5,0.25,1),-0.075,0.05,BrickColor.new("White"))
RH.C0=clerp(RH.C0,cf(1,-0.28,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-20),math.rad(40)),.5)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(10)),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.8)*angles(math.rad(40),math.rad(0),math.rad(70)),.5)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(-70)),.5)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(20),math.rad(-1),math.rad(30)),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50),math.rad(0),math.rad(-60)),.5)
end
	Speed = 67
	attacking = false
end

function SolarAttack()
	attacking = true
	Speed = 0
	local keptcolor = MAINCOLOR
	CFuncs["Sound"].Create("rbxassetid://289315275", char, 2.5,0.8)
CFuncs["Sound"].Create("rbxassetid://136007472", char, 2,0.76)
	for i = 0,10.6,0.1 do
swait()
PixelBlockX(5,0.5,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,0.5,0.01,MAINCOLOR,0)
sphere2(5,"Add",larm.CFrame*CFrame.new(math.random(-0.5,0.5),-0.9 + math.random(-0.5,0.5),math.random(-0.5,0.5)),vt(0.45,0.45,0.45),0.01,0.01,0.01,BrickColor.new("Deep orange"),BrickColor.new("Deep orange").Color)
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-60)),0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(60)),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sne / 28),0)*angles(math.rad(15),math.rad(15),math.rad(-10)),.2)
LW.C0=clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(170), math.rad(0), math.rad(-40)), 0.2)
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(0)),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(20),math.rad(5)),.2)
	end
	for i = 0, 4 do
slash(math.random(10,50)/10,3,true,"Round","Add","Out",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.0025,0.01),math.random(15,50)/3000,BrickColor.new("White"))
end
block(1,"Add",larm.CFrame*CFrame.new(0,-1,0),vt(0,0,0),0.05,0.05,0.05,keptcolor,keptcolor.Color)
	CFuncs["EchoSound"].Create("rbxassetid://675172759", root, 10, 0.8,0,10,0.15,0.5,1)
CFuncs["EchoSound"].Create("rbxassetid://763717897", root, 7.5, 1.1,0,10,0.15,0.5,1)
CFuncs["EchoSound"].Create("rbxassetid://675172759", root, 5, 0.7,0,10,0.15,0.5,1)
	sphere(1,"Add",mouse.Hit*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(3,100000,3),0.6,BrickColor.new("Deep orange"))
sphere(1,"Add",mouse.Hit,vt(2,2,2),1.6,BrickColor.new("Deep orange"))
for i = 0, 49 do
--PixelBlockX(1,math.random(1,20),"Add",mouse.Hit*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),8,8,8,0.16,BrickColor.new("Deep orange"),0)
sphereMK(2.5,-1,"Add",mouse.Hit*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,BrickColor.new("Deep orange"),0)
--slash(math.random(10,20)/10,5,true,"Round","Add","Out",mouse.Hit*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-30, 30)), math.rad(math.random(-30, 30)), math.rad(math.random(-40, 40))),vt(0.05,0.01,0.05),math.random(50,60)/250,BrickColor.new("Deep orange"))
end
for i, v in pairs(FindNearestHead(mouse.Hit.p, 25)) do
if v:FindFirstChild('Head') then
dmg(v)
end
end
	Speed = 36
	attacking = false
end
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end




function NuclearExtended()
attacking = true
Speed = 0
CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
local keptcolor = MAINCOLOR
for i = 0,4.3,0.1 do
swait()
sphere2(6,"Add",RightLeg.CFrame*CFrame.new(math.random(-0.5,0.5),-1.3 + math.random(-0.5,0.5),math.random(-0.5,0.5)),vt(0.45,0.45,0.45),0.01,0.01,0.01,MAINCOLOR,MAINCOLOR.Color)
RH.C0=clerp(RH.C0,cf(1,-0.15,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-20),math.rad(0),math.rad(10)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(-10)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-5),math.rad(-10),math.rad(20)),.1)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-5),math.rad(10),math.rad(-20)),.1)
end
CFuncs["Sound"].Create("rbxassetid://763717897", char, 2, 1)
CFuncs["Sound"].Create("rbxassetid://763717897", char, 2, 0.75)
CFuncs["Sound"].Create("rbxassetid://763717897", char, 2, 0.5)
CFuncs["Sound"].Create("rbxassetid://1192402877", char, 1,0.5)
CFuncs["Sound"].Create("rbxassetid://1664711478", char, 1.5,1)
CFuncs["Sound"].Create("rbxassetid://763718160", char, 2, 0.75)
for i, v in pairs(FindNearestHead(Torso.CFrame.p, 7)) do
if v:FindFirstChild('Head') then
dmg(v)
end
end

for i = 0,5.5,0.1 do
swait()
for i, v in pairs(FindNearestHead(Torso.CFrame.p, 56)) do
if v:FindFirstChild('Head') then
dmg(v)
end
end
sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(32,0.061111111,32),0.8,-0.000000000000002,0.8,BrickColor.new("Lime green"),Color3.new(0,1,0))
RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(10)),.8)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(10)),.8)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.05)*angles(math.rad(10),math.rad(0),math.rad(0)),.8)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(40),math.rad(0),math.rad(0)),.8)
RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(-35),math.rad(-10),math.rad(60)),.8)
LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(-35),math.rad(10),math.rad(-50)),.8)
end
attacking = false
Speed = 32
end

 
function negromancingnigrafyer9000(bitchasslilnigga)  
	    bitchasslilnigga:BreakJoints()
    for _, c in pairs(bitchasslilnigga:GetDescendants()) do
        if c:IsA("BasePart") and c.Transparency == 0 then
            c:BreakJoints()
            c.Material = "Neon"
            c.Color = BRICKC("Lime green").Color
            c.CanCollide = true
            c.Transparency = 0
            if c:FindFirstChildOfClass("SpecialMesh") then
                c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
            end
            if c.Name == "Head" then
                c:ClearAllChildren()
                c.Size = VT(c.Size.Y,c.Size.Y,c.Size.Y)
            end
            if c.ClassName == "MeshPart" then
                c.TextureID = ""
            end
            if c:FindFirstChildOfClass("BodyPosition") then
                c:FindFirstChildOfClass("BodyPosition"):remove()
            end
            if c:FindFirstChildOfClass("ParticleEmitter") then
                c:FindFirstChildOfClass("ParticleEmitter"):remove()
            end
            c.Velocity = VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))/15
            c.RotVelocity = VT(MRANDOM(-45,45),MRANDOM(-15,85),MRANDOM(-45,45))
        end
    end
end

function NuclearGrab()
attacking = true
Speed = 16
local yourdeadnoob=nil 
for i = 0,1.15,0.1 do
swait()
		if math.random(1,3) == 1 then
		PixelBlockX(7,0.5,"Add",rarm.CFrame*CFrame.new(0,-1.35,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,0.5,0.01,MAINCOLOR,0)
end
sphere2(6,"Add",rarm.CFrame*CFrame.new(math.random(-0.5,0.5),-1.35 + math.random(-0.5,0.5),math.random(-0.5,0.5)),vt(0.45,0.45,0.45),0.01,0.01,0.01,MAINCOLOR,MAINCOLOR.Color)
RH.C0=clerp(RH.C0,cf(1,-1,-0.15)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(1)),.8)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(1)),.8)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.05)*angles(math.rad(10),math.rad(0),math.rad(-52)),.8)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(52)),.8)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(87),math.rad(-2),math.rad(12)),.8)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-5),math.rad(2),math.rad(-8)),.8)
end
for i = 0,1.35,0.1 do
swait()
local BOI = FindNearestTorso(RightArm.Position,6)
if BOI ~= nil and yourdeadnoob == nil then
yourdeadnoob = BOI
CFuncs["Sound"].Create("rbxassetid://200632875", BOI, 3, 1)
end
if yourdeadnoob ~=nil then
yourdeadnoob.CFrame=RightArm.CFrame*CFrame.new(0,-1.3,0)*CFrame.Angles(-math.rad(90),math.rad(0),math.rad(0))
end
		if math.random(1,3) == 1 then
		PixelBlockX(7,0.5,"Add",rarm.CFrame*CFrame.new(0,-1.35,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,0.5,0.01,MAINCOLOR,0)
end
sphere2(6,"Add",rarm.CFrame*CFrame.new(math.random(-0.5,0.5),-1.35 + math.random(-0.5,0.5),math.random(-0.5,0.5)),vt(0.45,0.45,0.45),0.01,0.01,0.01,MAINCOLOR,MAINCOLOR.Color)
RH.C0=clerp(RH.C0,cf(1,-1,-0.15)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(1)),.8)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(1)),.8)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,-0.05)*angles(math.rad(10),math.rad(0),math.rad(32)),.8)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10),math.rad(0),math.rad(-32)),.8)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(87),math.rad(-2),math.rad(-2)),.8)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-5),math.rad(2),math.rad(-8)),.8)
end
if yourdeadnoob~=nil and yourdeadnoob.Parent~=nil then
	CFuncs["Sound"].Create("rbxassetid://199145534", yourdeadnoob, 8.21, 1.3)
		CFuncs["Sound"].Create("rbxassetid://206082327", yourdeadnoob, 7.12, .9)
			for i = 0, math.random(18,32) do
		sphereMK(2.5,-1,"Add",yourdeadnoob.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),1.9,1.9,25,-0.025,BrickColor.new("Lime green"),0)
		end
negromancingnigrafyer9000(yourdeadnoob.Parent)
end
attacking = false
Speed = 32
end

function NuclearTeleport()
attacking = true
Speed = 0
local yourdeadnoob=nil 
for i = 0,5,0.1 do
swait()
sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,0.5,1),0.1,0.01,0.1,BrickColor.new("Lime green"),Color3.new(0,1,0))
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.15 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(35 - 2 * math.cos(sine / 37)),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(90 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-80 + 2 * math.cos(sine / 45))),.3)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(80 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(71 - 4 * math.cos(sine / 45))),.3)
end
    RootPart.Anchored = true
			for i = 0, 32 do
sphere2(1.5,"Add",mouse.Hit*CFrame.new(0,-3,0),vt(1,0.5,1),0.1,0.01,0.1,BrickColor.new("Lime green"),Color3.new(0,1,0))
end
for i = 0,3,0.1 do
swait()
sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,0.5,1),0.1,0.01,0.1,BrickColor.new("Lime green"),Color3.new(0,1,0))
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.15 + 0.02 * math.cos(sine / 32),-30 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(35 - 2 * math.cos(sine / 37)),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(90 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-80 + 2 * math.cos(sine / 45))),.3)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(80 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(71 - 4 * math.cos(sine / 45))),.3)
end
			for i = 0, 32 do
sphere2(1.5,"Add",mouse.Hit*CFrame.new(0,-3,0),vt(1,0.5,1),0.1,0.01,0.1,BrickColor.new("Lime green"),Color3.new(0,1,0))
end
local AEEEEEEEEE = RootPart.Position
 RootPart.CFrame = CF(CF(mouse.Hit.p) * CF(0, 2.8, 0).p, AEEEEEEEEE)
for i = 0,5,0.1 do
swait()
sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,0.5,1),0.1,0.01,0.1,BrickColor.new("Lime green"),Color3.new(0,1,0))
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.15 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(35 - 2 * math.cos(sine / 37)),math.rad(0),math.rad(0)),.3)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(90 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-80 + 2 * math.cos(sine / 45))),.3)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(80 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(71 - 4 * math.cos(sine / 45))),.3)
end
RootPart.Anchored = false
attacking = false
Speed = 32
end

 
 

function kaboom()
attacking = true
--gale's typhoon move bootleg lol
for i = 0,2,0.1 do
MagicBlock(BrickColor.new("Institutional white"),sorb2.CFrame,1,1,1,0.1,0.1,0.1,0.25)
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-90)),0.2)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(0),math.rad(90)),.2)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(10)), 0.2)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.2)
	end

local a = Instance.new("Part",Character)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = BRICKC("Bright red")
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    sorb2.CFrame.p,                           -- origin
	    (mouse.Hit.p - sorb2.CFrame.p).unit * 500 -- direction
	) 
	local ignore = Character
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (root.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(sorb2.CFrame.p, position) * CFrame.new(0, 0, 0)
				 local lb = Instance.new("Part")
				CFuncs["Sound"].Create("rbxassetid://260433721", lb, 1, 1)
  lb.Parent = char
    lb.BrickColor = BrickColor.new("Pastel green")
     lb.CanCollide = false
lb.Material = "Neon"
     lb.Anchored = true
lb.TopSurface = 0
        lb.BottomSurface = 0
     lb.Transparency = 1
     lb.Size = vt(8,8,8)
     lb.CFrame = a.CFrame
lb.Anchored = false
--game:GetService("Debris"):AddItem(lb, 6)
  local bv = Instance.new("BodyVelocity")
  bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
  bv.velocity = a.CFrame.lookVector*46
  bv.Parent = lb
local hitted = false
game:GetService("Debris"):AddItem(a, 0.1)
coroutine.resume(coroutine.create(function()
while wait(0.025) do
if hitted == false or lb.Parent ~= nil then
	MagicBlock(BrickColor.new("Institutional white"),lb.CFrame,4,4,4,1.9,1.9,1.9,0.25)
	MagicBlock(BrickColor.new("White"),lb.CFrame,2,2,2,1.45,1.45,1.45,0.25)
	wind("Divide",lb.CFrame*CFrame.Angles(0,math.rad(math.random(-360,360)),0),Vector3.new(1,1,1),math.random(1,2),5,true)
if hitted == true or lb.Parent == nil then
break
end
end
end
end))
wait(0.01)
--game:GetService("Debris"):AddItem(lb, 7)
lb.Touched:connect(function(hit) 
MagniDamage(lb, 31, 12,32, 0, "Normal")
end)

attacking = false
wait(7)
lb:Remove()
end


function spinnyboi()
	attacking = true
	for i = 0,1,0.1 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),.1)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(90)), 0.1)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(-30), math.rad(0), math.rad(-90)), 0.1)
	end
CFuncs["Sound"].Create("rbxassetid://138079095", root, 0.5, 0.4)
CFuncs["Sound"].Create("rbxassetid://154723542", root, 1.5, 1.15)
coroutine.resume(coroutine.create(function()
	CFuncs["Sound"].Create("rbxassetid://588698460", root, 4.4, 1.5)
CFuncs["Sound"].Create("rbxassetid://588694531", root,4.4, 1.3)
sphere2(18.5,"Add",LeftArm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,2,2),1,1,1,BrickColor.new("Pastel green"),BrickColor.new("Pastel green").Color)
sphere2(18.5,"Add",RightArm.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(2,2,2),1,1,1,BrickColor.new("Pastel green"),BrickColor.new("Pastel green").Color)
for i = 0, 2 do
wait(0.05)
MagniDamage(root, 32, 12,42, 0, "Normal")
wind("Divide",root.CFrame*CFrame.Angles(0,math.rad(math.random(-360,360)),0),Vector3.new(2,2,2),0.8,26,false)
end
MagniDamage(root, 32, 12,42, 0, "Normal")
end))
	for i = 0,1.9,0.5 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(90)),0.5)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.5)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
	end
	for i = 0,1.9,0.5 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(180)),0.5)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.5)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
	end
	for i = 0,1.9,0.5 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(270)),0.5)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.5)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
	end
	for i = 0,1.9,0.5 do
		swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(360)),0.5)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.5)
             RW.C0 = clerp(RW.C0, CFrame.new(1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(90)), 0.5)
             LW.C0 = clerp(LW.C0, CFrame.new(-1.45, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-90)), 0.5)
	end
	attacking = false
end

function AAAA()
	attacking=true
	for i = 0,3,0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-.5,-.5)*angles(math.rad(-35),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.2)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*angles(math.rad(-15),0,math.rad(0)),.2)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-12),0,math.rad(-0)),.2)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(115),0,math.rad(-25)),.2)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(115),0,math.rad(25)),.2)
	end
	CFuncs["Sound"].Create("rbxassetid://438666141", root, 7.5,1)
	CFuncs["Sound"].Create("rbxassetid://1208650519", root, 7.5, 1)
	for i = 0,.5,0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1,-.5)*angles(math.rad(25),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.6)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(-5),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-.2,0)*angles(math.rad(25),0,0),.6)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko,.4)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-45),0,math.rad(25)),.4)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-45),0,math.rad(-25)),.4)
	end
	local out=5
	local start=root.CFrame
	coroutine.wrap(function()
		for rad = 0, 180,5 do
			out = out + 5
			local A = PyramidEffect:Clone()
			A.Parent = char
			A.CanCollide = true
			A.Anchored = true
			A.CFrame=start*cf(0,-15,-out)
			MagniDamage(A, 20, 65,187, 0, "Normal")
			coroutine.wrap(function()
				for i = -15, 0 do
					A.CFrame=A.CFrame*cf(0,1,0)
					swait()
				end
				delay(0.8,function()
					for i = -8, 0 do
						swait()
						A.CFrame=A.CFrame*cf(0,-1,0)
					end
					A:destroy()
				end)
			end)()
			swait()
		end
	end)()
	
	for i = 0,2.5,0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-1,-.5)*angles(math.rad(25),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.6)
		LH.C0=clerp(LH.C0,cf(-1,-1.1,0)*angles(math.rad(-5),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.4)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-.2,0)*angles(math.rad(25),0,0),.6)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko,.4)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-45),0,math.rad(25)),.4)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-45),0,math.rad(-25)),.4)
	end
	attacking=false
end


function CrystalizedFields()
attacking = true
Speed = 2
local keptcolor = MAINCOLOR
local obj1 = Instance.new("Part")
obj1.Parent = char
obj1.Transparency = 1
obj1.CanCollide = false
local rval = 0
local eval = 1
local tval = 0
CFuncs["Sound"].Create("rbxassetid://199145761", obj1, 3,1)
local eff = Instance.new("ParticleEmitter",obj1)
eff.Texture = "rbxassetid://2344870656"
eff.LightEmission = 1
eff.Color = ColorSequence.new(obj1.Color)
eff.Rate = 10000000
eff.Enabled = true
eff.EmissionDirection = "Left"
eff.Lifetime = NumberRange.new(0.5)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.1,10,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(5,50)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.RotSpeed = NumberRange.new(-500,500)
sphere2(5,"Add",root.CFrame*CFrame.new(0,5,0),vt(1,1,1),0.5,0.005,0.5,MAINCOLOR,MAINCOLOR.Color)
local eff2 = Instance.new("ParticleEmitter",obj1)
eff2.Texture = "rbxassetid://695499847"
eff2.LightEmission = 1
eff2.Color = ColorSequence.new(obj1.Color)
eff2.Rate = 12500
eff2.Lifetime = NumberRange.new(0.5,2)
eff2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(0.8,2,0),NumberSequenceKeypoint.new(1,0,0)})
eff2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff2.Speed = NumberRange.new(20,150)
eff2.Drag = 5
eff2.Rotation = NumberRange.new(-500,500)
eff2.VelocitySpread = 9000
eff2.RotSpeed = NumberRange.new(-150,150)
for i = 0,11,0.1 do
swait()
rval = rval + 10
eval = eval + 1.5
obj1.Transparency = 1
tval = tval + 1
if tval == 24 then
	tval = 0
	MagniDamage(Torso, 38, 12,21, 0, "Freeze",153092213)
end
obj1.Size = obj1.Size + vt(0,0.2,0.2)
obj1.CFrame = root.CFrame*CFrame.new(0,5,0)*CFrame.Angles(math.rad(0),math.rad(rval),math.rad(-90))
RH.C0=clerp(RH.C0,cf(1,-1 + 0.15 * math.cos(sine / 32),-0.15)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 32))),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 + 0.15* math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 2 * math.cos(sine / 32))),.3)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),-0.1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(2)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(-2 + 1 * math.cos(sine / 58)),math.rad(-2 + 2 * math.cos(sine / 53))),.3)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(1760 + 6 * math.cos(sine / 72)),math.rad(1 - 1 * math.cos(sine / 58)),math.rad(90 + 2 * math.cos(sine / 45))),.3)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(176 - 7 * math.cos(sine / 66)),math.rad(1 - 1 * math.cos(sine / 59)),math.rad(-90 - 4 * math.cos(sine / 45))),.3)
end
eff.Enabled = false
coroutine.resume(coroutine.create(function()
	for i = 0,49 do
		swait()
		rval = rval + 100
		obj1.Transparency = obj1.Transparency + 0.02
		obj1.Size = obj1.Size + vt(0,-0.5,-0.5)
	end
	obj1:Destroy()
end))
attacking = false
Speed = 14
end

function modeswitchgui()
local oawkwodkwad=math.random(0,100)/100
local okaofwakf=math.random(60,100)/100
local framiee=Instance.new("Frame",MainFrame2.Cube1)
framiee.AnchorPoint=Vector2.new(.5,.5)
framiee.Position=UDim2.new(.5,0,.5,0)
framiee.BorderSizePixel=0
framiee.BackgroundColor3=MainFrame2.Cube1.BackgroundColor3
framiee.Size=UDim2.new(0,0,0,0)
framiee.ZIndex=13
CFuncs["Sound"].Create("rbxassetid://557322397", MainGui, 3, 2.6)
for zi=1,3 do
local imfhg=Instance.new("ImageLabel",MainFrame2)
imfhg.AnchorPoint=Vector2.new(.5,.5)
imfhg.Position=UDim2.new(.6,0,.6,0)
imfhg.BorderSizePixel=0
imfhg.ImageColor3=MainFrame2.Cube1.BackgroundColor3
imfhg.Size=UDim2.new(.4,0,.7,0)
imfhg.ZIndex=10
imfhg.BackgroundTransparency=1
imfhg.Image="rbxassetid://2809225827"
coroutine.resume(coroutine.create(function(imag)
if zi==1 then
imag:TweenPosition(UDim2.new(.6,0,-1.5,0),"Out","Quint",1.2,true)
elseif zi==2 then
imag.Rotation=-45
imag:TweenPosition(UDim2.new(-.5,0,-1.2,0),"Out","Quint",1.2,true)
else
imag.Rotation=-90
imag:TweenPosition(UDim2.new(-.8,0,.6,0),"Out","Quint",1.2,true)
end
game:GetService("Debris"):AddItem(imag,3)
for i=0,1.02,.02 do
swait()
imag.ImageTransparency=i
end
imag:Remove()
end),imfhg)

end


coroutine.resume(coroutine.create(function(ff)
ff:TweenSize(UDim2.new(12,0,12,0),"Out","Quint",.8,true)
game:GetService("Debris"):AddItem(ff,3)
for i=0,1.02,.04 do
swait()
ff.BackgroundTransparency=i
ff.Rotation=ff.Rotation+3.5
end
ff:Remove()
end),framiee)

end


mouse.KeyDown:connect(function(Button)
if Button == "m" and attacking == false and Mode == "FL" then
Mode = "DM"
if math.random(1,2) == 1 then
SONG = 705302406
else
SONG = 580367180
end
MAINCOLOR = BrickColor.new("Persimmon")
MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Pink").Color
MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Persimmon").Color
modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Persimmon").Color
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Persimmon").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Persimmon").Color
end
end
end
TextUI.Text.Image = "rbxassetid://2969037917"
Speed = 20
		elseif Mode == "DM" and Button == "m" and attacking == false then
			Mode = "FL"
			SONG = 1886156023
			MAINCOLOR = BrickColor.new("Dark blue")
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Dark blue").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Dark blue").Color
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Dark blue").Color
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Dark blue").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Dark blue").Color
end
end
end
TextUI.Text.Image = "rbxassetid://2968625581"
Speed = 46
end

	if Button == "m" and attacking == false then
		if Mode == "T" then
			Mode = "LS"
			SONG = 2170417538
			MAINCOLOR = BrickColor.new("Toothpaste")
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Toothpaste").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Toothpaste").Color
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Toothpaste").Color
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Toothpaste").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Toothpaste").Color
end
end
end
TextUI.Text.Image = "rbxassetid://2866248691"
Speed = 67
		elseif Mode == "LS" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
end
	end
-----------------------------------------------------------------
	if Button == "g" and attacking == false then
		if Mode == "T" then
			Mode = "ICE"
			SONG = 1843801674
			MAINCOLOR = BrickColor.new("Pastel light blue")
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Pastel light blue").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Pastel light blue").Color
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Pastel light blue").Color
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Pastel light blue").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Pastel light blue").Color
end
end
end
TextUI.Text.Image = "rbxassetid://2967532910"
Speed = 14
		elseif Mode == "ICE" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
		end
	end
-----------------------------------------------------------------
	if Button == "f" and attacking == false then
		if Mode == "T" then
			Mode = "FL"
			SONG = 1886156023
			MAINCOLOR = BrickColor.new("Dark blue")
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Dark blue").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Dark blue").Color
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Dark blue").Color
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Dark blue").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Dark blue").Color
end
end
end
TextUI.Text.Image = "rbxassetid://2968625581"
Speed = 46
		elseif Mode == "FL" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
		end
	end
	
-----------------------------------------------------------------
		if Button == "n" and attacking == false then
		if Mode == "T" then
			Mode = "G"
			SONG = 930541401
		swait(1)
		modeswitchgui()
		elseif Mode == "G" then
			SONG = 570332815
			Mode = "T"
		modeswitchgui()
		end
		end
		-----------------------------------------------------------------
		if Button == "b" and attacking == false then
			
		if Mode == "T" then
			Mode = "R"
			Speed = 47
			SONG = 1988896150
		swait(1)
		modeswitchgui()
		elseif Mode == "R" then
			SONG = 570332815
			Speed = 18
			Mode = "T"
		modeswitchgui()
		end
		end
		-----------------------------------------------------------------
		if Button == "j" and attacking == false then
		if Mode == "T" then
			Mode = "N"
			MAINCOLOR = BRICKC'Lime green'
			Speed = 32
			SONG = 566809627
		swait(1)
		modeswitchgui()
		elseif Mode == "N" then
			SONG = 570332815
			Speed = 18
			Mode = "T"
			MAINCOLOR = BRICKC'Lime green'
		modeswitchgui()
		end
		end
		-----------------------------------------------------------
			if Button == "h" and attacking == false then
		if Mode == "T" then
			Mode = "TP"
			SONG = 631314940
			MAINCOLOR = BrickColor.new("Institutional white")
		MainFrame2.Cube1.BackgroundColor3=C3(1,1,1)
		MainFrame2.Cube2.BackgroundColor3=C3(1,1,1)
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(1,1,1)
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(1,1,1)
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(1,1,1)
end
end
end
TextUI.Text.Image = "rbxassetid://2878494513"
Speed = 89
		elseif Mode == "TP" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
		end
	end
		-----------------------------------------------------------
					if Button == "q" and attacking == false then
		if Mode == "T" then
			Mode = "MH"
			SONG = 1356751414
			MAINCOLOR = BrickColor.new("Really red")
		MainFrame2.Cube1.BackgroundColor3=C3(1,0,0)
		MainFrame2.Cube2.BackgroundColor3=C3(1,0,0)
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(1,0,0)
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(1,0,0)
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(1,0,0)
end
end
end
TextUI.Text.Image = "rbxassetid://2970613902"
Speed = 32
		elseif Mode == "MH" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
		end
	end
		-----------------------------------------------------------
			if Button == "v" and attacking == false then
		if Mode == "T" then
			Mode = "MN"
			SONG = 901719740
			MAINCOLOR = BrickColor.new("Really blue")
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Really blue").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Really blue").Color
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Really blue").Color
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Really blue").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Really blue").Color
end
end
end
TextUI.Text.Image = "rbxassetid://2867768707"
Speed = 43
		elseif Mode == "MN" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
		end
			end
			---------------------------------------------------------
						if Button == "l" and attacking == false then
		if Mode == "T" then
			Mode = "H"
			SONG = 2781731664
			MAINCOLOR = BrickColor.new("Deep orange")
		MainFrame2.Cube1.BackgroundColor3=C3(225/255, 146/255, 0/255)
		MainFrame2.Cube2.BackgroundColor3=C3(225/255, 146/255, 0/255)
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(225/255, 146/255, 0/255)
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(225/255, 146/255, 0/255)
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = C3(225/255, 146/255, 0/255)
end
end
end
TextUI.Text.Image = "rbxassetid://2871051104"
Speed = 36
		elseif Mode == "H" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
		end
						end
	---------------------------------------------------------
	if Button == "k" and attacking == false then
		if Mode == "T" then
			Mode = "A"
			SONG = 2834885098
			MAINCOLOR = BrickColor.new("New Yeller")
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("New Yeller").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("New Yeller").Color
		modeswitchgui()
for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("New Yeller").Color
end
end
end
for i,v in pairs(TurboCore:GetChildren()) do
				if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("New Yeller").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("New Yeller").Color
end
end
end
TextUI.Text.Image = "rbxassetid://2871442888"
Speed = 23
		elseif Mode == "A" then
			SONG = 570332815
			Mode = "T"
			Speed = 18
			MAINCOLOR = BrickColor.new("Deep orange")
			TextUI.Text.Image = "rbxassetid://2863687732"
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
		modeswitchgui()
for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
		end
	end
		---------------------ATTACKS--------------------------
				if Button == "z" and attacking == false and Mode == "G" then
					glitchattack()
				end
				
				if Button == "z" and attacking == false and Mode == "LS" then
					Daash()
				end
				
				if Button == "x" and attacking == false and Mode == "MN" then
					LunarAttack()
				end
				
				if Button == "z" and attacking == false and Mode == "MN" then
					LunarAttackA()
				end
				
				if Button == "z" and attacking == false and Mode == "H" then
					SolarAttack()
				end
								
				if Button == "z" and attacking == false and Mode == "N" then
					NuclearExtended()
				end
				if Button == "x" and attacking == false and Mode == "N" then
					NuclearGrab()
				end
				if Button == "c" and attacking == false and Mode == "N" then
					NuclearTeleport()
				end
				if Button == "z" and attacking == false and Mode == "ICE" then
					CrystalizedFields()
				end
				if Button == "z" and attacking == false and Mode == "TP" then
					kaboom()
				end
				if Button == "x" and attacking == false and Mode == "TP" then
					spinnyboi()
				end
				if Button == "z" and attacking == false and Mode == "A" then
					AAAA()
				end
				if Button == "z" and attacking == false and Mode == "FL" then
					--FL is meant to make lots of combos
					--so yeah
					--also make techno effects for the attacks
					--its kinda related to slush invaders
	--x5
				end
					----------------TAUNTS-----------------------------------------
	if Button == "p" and attacking == false then
		if Chill == false then
Chill = true
		elseif Chill == true then
			Chill = false
		end
	end
end)

local owakdoa=0
function gagok()
local oawkwodkwad=math.random(0,100)/100
local okaofwakf=math.random(60,100)/100
local framiee=Instance.new("Frame",MainFrame2)
framiee.AnchorPoint=Vector2.new(.5,.5)
framiee.Position=UDim2.new(oawkwodkwad,0,2,0)
framiee.BorderSizePixel=0
framiee.BackgroundColor3=MainFrame2.Cube1.BackgroundColor3
framiee.Size=UDim2.new(math.random(1,15)/100,0,okaofwakf,0)
coroutine.resume(coroutine.create(function(ff)
ff:TweenSize(UDim2.new(0,0,okaofwakf,0),"InOut","Quad",1,true)
ff:TweenPosition(UDim2.new(oawkwodkwad,0,-math.random(20,66)/100,0),"InOut","Quart",1.1,true)
game:GetService("Debris"):AddItem(ff,5)
end),framiee)

end

local BOIE = 0

while true do
	swait()
	if Mode ~= "ICE" then
	sne = sne + chaeng
	else
		sne = sne + 0.625
		end
timepoz = music.TimePosition
music.SoundId = "rbxassetid://"..SONG
if luna.Parent ~= nil then
	sphere2(5,"Add",luna.CFrame,vt(0.525,0.525,0.525),0.001,0.001,0.001,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
--sphere2(5,"Add",luna.CFrame*CFrame.new(math.random(-0.555,0.555),math.random(-0.555,0.555),math.random(-0.555,0.555)),vt(0.125,0.125,0.125),0.001,0.001,0.001,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
end
--sphere2(5,"Add",luna.CFrame*CFrame.new(math.random(-0.5,0.5),math.random(-0.5,0.5),math.random(-0.5,0.5)),vt(0.25,0.25,0.25),0.01,0.01,0.01,BrickColor.new("Bright blue"),BrickColor.new("Bright blue").Color)
luna.CFrame = sorb.CFrame*CF(0,-0.75,0)*ANGLES(RAD(360*math.cos(sne/168)),math.rad(360*math.cos(sne/168)),math.rad(360*math.cos(sne/168)))
if Mode ~= "MN" then
	luna.Parent = nil
elseif Mode == "MN" then
	luna.Parent = char
end
if Mode == "T" then
music.Volume = 2
elseif Mode == "LS" then
	music.Volume = 5
elseif Mode ~= "LS" and Mode ~= "T" then
	music.Volume = 3.5
	end
if music.Parent ~= char.HumanoidRootPart then
music = Instance.new("Sound",char.HumanoidRootPart)
music.SoundId = "rbxassetid://"..SONG
music.Looped = true
music.Pitch = 1
if Mode == "T" then
music.Volume = 2
elseif Mode == "LS" then
	music.Volume = 5
	elseif Mode ~= "LS" and Mode ~= "T" then
	music.Volume = 3.5
	end
music.TimePosition = timepoz
music:Resume()	
end
if Mode ~= "G" then
TextUI.Text.Rotation = 2 *math.cos(sne/32)
else
	TextUI.Text.Rotation = math.random(-2,2)
	end
if Mode == "G" then
	glitchval = math.random(1,255)/255
	if math.random(1,3) == 1 then
			for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
	v.Material = "Slate"
			v.Transparency = math.random(0.1,1.0)
v.Color = Color3.new(glitchval,glitchval,glitchval)
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
		v.Material = "Slate"
				v.Transparency = math.random(0.1,1.0)
v.Color = Color3.new(glitchval,glitchval,glitchval)
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
		v.Material = "Slate"
		v.Transparency = math.random(0.1,1.0)
v.Color = Color3.new(glitchval,glitchval,glitchval)
end
end
end
					TextUI.Text.Image = "rbxassetid://2866315054"
	else
		if math.random(1,25) == 1 then
		PixelBlockNeg(1,math.random(1,2),"Add",RootPart.CFrame*CFrame.new(math.random(-15,15),0,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),5,5,5,0.1,BrickColor.new("Institutional white"),-10)
				end
					TextUI.Text.Image = "rbxassetid://2866314462"
		MainFrame2.Cube1.BackgroundColor3= Color3.new(glitchval,glitchval,glitchval)
		MainFrame2.Cube2.BackgroundColor3= Color3.new(glitchval,glitchval,glitchval)
			for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
	v.Material = "Neon"
			v.Transparency = 0
v.Color = Color3.new(glitchval,glitchval,glitchval)
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
		v.Material = "Neon"
				v.Transparency = 0
v.Color = Color3.new(glitchval,glitchval,glitchval)
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
		v.Material = "Neon"
				v.Transparency = 0
v.Color = Color3.new(glitchval,glitchval,glitchval)
end
end
end
	end
elseif Mode ~= "G" then
				for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
	v.Material = "Neon"
			v.Transparency = 0
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
	v.Material = "Neon"
			v.Transparency = 0
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
	v.Material = "Neon"
			v.Transparency = 0
end
end
end
if Mode == "T" then
				TextUI.Text.Image = "rbxassetid://2863687732"
	for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
end

if Mode == "N" then
		if hitfloor ~= nil then
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,0.5,1),0.1,0.01,0.1,BrickColor.new("Lime green"),Color3.new(0,1,0))
	end
	if math.random(1,2) == 1 then
	TextUI.Text.Image = "rbxassetid://2874580999"
	else
	TextUI.Text.Image = "rbxassetid://2874633415"
		end
		MainFrame2.Cube1.BackgroundColor3=Color3.fromRGB(15 + math.random(-15,15), 158 + math.random(-30,30), 15 + math.random(-15,15))
		MainFrame2.Cube2.BackgroundColor3=Color3.fromRGB(15 + math.random(-15,15), 158 + math.random(-30,30), 15 + math.random(-15,15))
	for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = Color3.fromRGB(15 + math.random(-15,15), 158 + math.random(-30,30), 15 + math.random(-15,15))
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = Color3.fromRGB(15 + math.random(-15,15), 158 + math.random(-30,30), 15 + math.random(-15,15))
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = Color3.fromRGB(15 + math.random(-15,15), 158 + math.random(-30,30), 15 + math.random(-15,15))
end
end
end
end
end
if Mode == "R" then
					TextUI.Text.Image = "rbxassetid://2866469300"
						TextUI.Text.ImageColor3 = Color3.new(r/255,g/255,b/255)
		MainFrame2.Cube1.BackgroundColor3=Color3.new(r/255,g/255,b/255)
		MainFrame2.Cube2.BackgroundColor3=Color3.new(r/255,g/255,b/255)
	for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = Color3.new(r / 255, g / 255, b / 255)
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = Color3.new(r / 255, g / 255, b / 255)
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = Color3.new(r / 255, g / 255, b / 255)
end
end
end
elseif Mode ~= "R" then
	TextUI.Text.ImageColor3 = Color3.new(255/255,255/255,255/255)
	if Mode == "T" then
		MainFrame2.Cube1.BackgroundColor3=BrickColor.new("Deep orange").Color
		MainFrame2.Cube2.BackgroundColor3=BrickColor.new("Deep orange").Color
				TextUI.Text.Image = "rbxassetid://2863687732"
	for i,v in pairs(TurboCore:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
			for i,v in pairs(gauntlet:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
for i,v in pairs(gauntlet2:GetChildren()) do
if v:IsA("BasePart") then
if v.Name == "NeonArmor" then
v.Color = BrickColor.new("Deep orange").Color
end
end
end
end
end
sine = sne
if Mode == "ICE" then
	BOIE = BOIE + 1
	if BOIE == 32 then
		BOIE = 0
CrystalEffect(2.2,math.random(-6,6),"Add",root.CFrame*CFrame.new(math.random(-125,125),25,math.random(-125,125))*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),50,50,50,-0.03,0)
if math.random(1,4) == 1 then
	CrystalEffect(2.2,math.random(-6,6),"Add",root.CFrame*CFrame.new(math.random(-125,125),25,math.random(-125,125))*CFrame.Angles(math.rad(math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),50,50,50,-0.03,0)
end
end
end



--TriangleEffect(7.5,0,"Add",root.CFrame*CFrame.Angles(math.rad(sne),math.rad(sne),math.rad(sne)),0.03,0)

----------SALVO'S GUI---------
MainFrame2.ImageLabel.Image = TextUI.Text.Image
MainFrame2.ImageLabel.Rotation = 5 * math.cos(sine/31)
MainFrame2.ImageLabel.ImageColor3 = TextUI.Text.ImageColor3
MainFrame2.Cube1.Rotation = MainFrame2.Cube1.Rotation + (1+.9*math.sin(sine / 31) + music.PlaybackLoudness/123)
MainFrame2.Cube2.Rotation = MainFrame2.Cube2.Rotation + (2-.9*math.cos(sine / 31) + music.PlaybackLoudness/88)
MainFrame2.Cube1.Size = UDim2.new(0,200 + music.PlaybackLoudness/14,0,200 + music.PlaybackLoudness/14)
MainFrame2.Cube2.Size = UDim2.new(0,160 + music.PlaybackLoudness/21,0,160 + music.PlaybackLoudness/21)

local bruh1=MainFrame2.Cube1.BackgroundColor3.r
local bruh2=MainFrame2.Cube1.BackgroundColor3.g
local bruh3=MainFrame2.Cube1.BackgroundColor3.b

MainFrame2.Cube1.mg1.ImageColor3=Color3.new(bruh1-(.15+.2*math.sin(sine/19)),bruh2-(.15+.2*math.sin(sine/19)),bruh3-(.15+.2*math.sin(sine/19)))
MainFrame2.Cube1.mg2.ImageColor3=Color3.new(bruh1-(.15+.2*math.sin(sine/19)),bruh2-(.15+.2*math.sin(sine/19)),bruh3-(.15+.2*math.sin(sine/19)))
MainFrame2.Cube1.mg3.ImageColor3=Color3.new(bruh1-(.15+.2*math.sin(sine/19)),bruh2-(.15+.2*math.sin(sine/19)),bruh3-(.15+.2*math.sin(sine/19)))
MainFrame2.Cube1.mg4.ImageColor3=Color3.new(bruh1-(.15+.2*math.sin(sine/19)),bruh2-(.15+.2*math.sin(sine/19)),bruh3-(.15+.2*math.sin(sine/19)))
MainFrame2.Cube2.mg1.ImageColor3=Color3.new(bruh1-(.15+.22*math.cos(sine/18)),bruh2-(.15+.22*math.cos(sine/18)),bruh3-(.15+.22*math.cos(sine/18)))
MainFrame2.Cube2.mg2.ImageColor3=Color3.new(bruh1-(.15+.22*math.cos(sine/18)),bruh2-(.15+.22*math.cos(sine/18)),bruh3-(.15+.22*math.cos(sine/18)))
MainFrame2.Cube2.mg3.ImageColor3=Color3.new(bruh1-(.15+.22*math.cos(sine/18)),bruh2-(.15+.22*math.cos(sine/18)),bruh3-(.15+.22*math.cos(sine/18)))
MainFrame2.Cube2.mg4.ImageColor3=Color3.new(bruh1-(.15+.22*math.cos(sine/18)),bruh2-(.15+.22*math.cos(sine/18)),bruh3-(.15+.22*math.cos(sine/18)))

			SideFrame2.BorderColor3 = MainFrame2.Cube1.BackgroundColor3
									SideFrame2.BackgroundColor3 = MainFrame2.Cube1.BackgroundColor3
			SideFrame3.BorderColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame3.BackgroundColor3 = MainFrame2.Cube1.BackgroundColor3
									SideFrame4.BorderColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame4.BackgroundColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame5.BorderColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame5.BackgroundColor3 = MainFrame2.Cube1.BackgroundColor3
											SideFrame0.BorderColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame0.BackgroundColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame_0.BorderColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame_0.BackgroundColor3 = MainFrame2.Cube1.BackgroundColor3
											SideFrame1.BorderColor3 = MainFrame2.Cube1.BackgroundColor3
						SideFrame1.BackgroundColor3 = MainFrame2.Cube1.BackgroundColor3
					SideFrame_0.Size = UDim2.new(0,35+music.PlaybackLoudness/16,0,15)
					SideFrame0.Size = UDim2.new(0,45+music.PlaybackLoudness/14,0,15)
					SideFrame1.Size = UDim2.new(0,55+music.PlaybackLoudness/12,0,15)
			SideFrame2.Size = UDim2.new(0,65+music.PlaybackLoudness/10,0,15)
						SideFrame3.Size = UDim2.new(0,75+music.PlaybackLoudness/8,0,15)
			SideFrame4.Size = UDim2.new(0,85+music.PlaybackLoudness/6,0,15)
						SideFrame5.Size = UDim2.new(0,95+music.PlaybackLoudness/4,0,15)

owakdoa=owakdoa+1
if owakdoa>=4 then
	owakdoa=0
gagok()	
end
---------------------------------------------------------------------
if char:FindFirstChild("CharacterMesh") then
	char.CharacterMesh:Remove()
end
	if char:FindFirstChild("Animate") then
		char.Animate:Remove()
	end
		if char:FindFirstChild("Animator") then
		char.Animate:Remove()
		end
				if char:FindFirstChild("ForceField") then
		char.ForceField:Remove()
		end
			if char.Humanoid:FindFirstChild("Animate") then
		char.Humanoid.Animate:Remove()
			end
				if char.Humanoid:FindFirstChild("Animator") then
		char.Humanoid.Animator:Remove()
	end
char.Humanoid.WalkSpeed = Speed
char.Humanoid.JumpPower = 90
local TorsoVelocity=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if RootPart.Velocity.y > 1 and hitfloor==nil then 
ANIMATION="Jump"
if attacking==false then
RightH.C0=clerp(RightH.C0,cf(1,-0.35 - 0.05 * math.cos(sne / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sne / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sne / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sne / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
ANIMATION="Fall"
if attacking==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
end
elseif TorsoVelocity<1 and hitfloor~=nil then
ANIMATION="Idle"
if attacking==false then
	if Chill == false then
	if Mode == "T" then
--RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.08 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
--LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.08 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
--RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0,0 + 0.085 * math.cos(sne / 32))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
--Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
	RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 - 3 * math.cos(sne / 32))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 + 3 * math.cos(sne / 32))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sne / 32))*angles(math.rad(0 - 2 * math.cos(sne / 32)),math.rad(0),math.rad(-1)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(5 - 2 * math.cos(sne / 37)),math.rad(0 + 1 * math.cos(sne / 58)),math.rad(1 + 2 * math.cos(sne / 53))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sne / 45),0)*angles(math.rad(2 + 5 * math.cos(sne / 74)),math.rad(1 - 3 * math.cos(sne / 53)),math.rad(14 + 3 * math.cos(sne / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sne / 45),0)*angles(math.rad(5 - 3 * math.cos(sne / 73)),math.rad(2 - 1 * math.cos(sne / 55)),math.rad(-18 - 3 * math.cos(sne / 45))),.1)
--RightS.C0 = clerp2(RightS.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12+3*math.cos(sne/32))) * CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.15 / 3)
 --LeftS.C0 = clerp2(LeftS.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12-3*math.cos(sne/32))) * CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.15 / 3)
	elseif Mode == "LS" then
		RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.05 * math.cos(sne / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5 + 0.5 * math.cos(sne / 34)),math.rad(6 + 3 * math.cos(sne / 34)),math.rad(0 - 1 * math.cos(sne / 34))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5 + 0.25 * math.cos(sne / 34)),math.rad(8 - 2 * math.cos(sne / 34)),math.rad(0 + 1 * math.cos(sne / 34))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0 + 0.01 * math.cos(sne / 34),0 + 0.05 * math.cos(sne / 28))*angles(math.rad(0 - 1 * math.cos(sne / 34)),math.rad(0),math.rad(18 + 3 * math.cos(sne / 65))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(12 - 3.5 * math.cos(sne / 28)),math.rad(3 * math.cos(sne / 32) + 0.5 * math.cos(sne / 28)),math.rad(-18 - 3 * math.cos(sne / 65))),.1)
RW.C0=clerp(RW.C0,cf(0.85,0.4 + 0.06 * math.cos(sne / 28),-0.65)*angles(math.rad(36 - 3 * math.cos(sne / 34)),math.rad(-2 + 2 * math.cos(sne / 45)),math.rad(-88 + 2 * math.cos(sne / 28))),.1)
LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.06 * math.cos(sne / 28),-0.65)*angles(math.rad(46 + 3 * math.cos(sne / 49)),math.rad(2 - 2 * math.cos(sne / 52)),math.rad(88 - 3 * math.cos(sne / 39))),.1)
    elseif Mode == "DM" then -- GodzPlaysRB's Floppy doppy animation
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0 + 15 * math.cos(sine / 28)),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0 + 15 * math.cos(sine / 28)),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 + 15 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 7 * math.cos(sine / 28)),math.rad(0 + 10 * math.cos(sine / 28)),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0 + 1 * math.cos(sine / 28)),math.rad(0 + 25 * math.cos(sine / 28)),math.rad(20 - 5 * math.sin(sine / 28))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0 + 2 * math.cos(sine / 28)),math.rad(0 - 27 * math.cos(sine / 28)),math.rad(-20 + 5 * math.sin(sine / 28))),.1)
	elseif Mode == "G" then
		RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 - 2 * math.cos(sne / 32))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 + 2 * math.cos(sne / 32))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0 + 0.02 * math.cos(sne / 32),-0.1 + 0.05 * math.cos(sne / 32))*angles(math.rad(0 - 2 * math.cos(sne / 32)),math.rad(0),math.rad(-11)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(11 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(10 - 2.5 * math.cos(sne / 28)),math.rad(0),math.rad(31 + 6.5 * math.cos(sne / 32.5))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(math.random(1,3)),math.rad(-5),math.rad(15 + 7.5 * math.cos(sne / 32.5))),.1)
LW.C0=clerp(LW.C0,cf(-1.5+0.05*math.cos(sne/32),0.65-.05*math.cos(sne/32),0)*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(math.random(136,159)),math.rad(5),math.rad(29 - 8.5 * math.cos(sne / 32.5))),.1)
		elseif Mode == "MH" then
		RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(24 - 2 * math.cos(sne / 32))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(-24 + 2 * math.cos(sne / 32))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0 + 0.02 * math.cos(sne / 32),-0.1 + 0.05 * math.cos(sne / 32))*angles(math.rad(24 - 2 * math.cos(sne / 32)),math.rad(0),math.rad(-6)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(15 - 15 * math.cos(sne / 0.5265)),math.rad(11 - 15 * math.cos(sne / 0.25)),math.rad(0 - 15 * math.cos(sne / 0.465)))*angles(math.rad(21 - 2.5 * math.cos(sne / 28)),math.rad(0),math.rad(4 + 6.5 * math.cos(sne / 1.5))),.1)
RW.C0=clerp(RW.C0,cf(1,0.695,-0.5)*angles(math.rad(150 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.5265)),math.rad(-42 - 1.5 * math.cos(sine / 25) + 15 * math.cos(sne / 0.5265))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(23 - 15 * math.cos(sne / 0.5265)),math.rad(0 - 15 * math.cos(sne / 0.5265)),math.rad(-25 - 15 * math.cos(sne / 0.5265))),.1)
	elseif Mode == "MN" then
		RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),-0.15)*angles(math.rad(0),math.rad(82.5),math.rad(0))*angles(math.rad(-7),math.rad(-1 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-82.5),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(3 + 2 * math.cos(sine / 32))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(11-3*math.cos(sne/32))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(11 - 2 * math.cos(sine / 37)),math.rad(-2 + 2 * math.cos(sine / 58)),math.rad(-3+3*math.cos(sine/24))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-6 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(15 + 6 * math.cos(sine / 45))),.2)
LW.C0=clerp(LW.C0,cf(-1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(67 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.2)
	elseif Mode == "H" then
RH.C0 = clerp(RH.C0, CF(1, -1 - 0.07 * math.cos(sine / 22), 0) * angles(math.rad(0), math.rad(85), math.rad(0)) * angles(math.rad(-2.5 - 0.5 * math.sin(sine / 22)), math.rad(0), math.rad(-2)), 0.1)
LH.C0 = clerp(LH.C0, CF(-1, -1 - 0.07 * math.cos(sine / 22), 0) * angles(math.rad(0), math.rad(-78), math.rad(0)) * angles(math.rad(-2.5 - 0.5 * math.sin(sine / 22)), math.rad(0), math.rad(-5)), 0.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.07 * math.cos(sine / 22))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(-35)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 3 * math.cos(sine / 31)),math.rad(0),math.rad(34)),.1)
	RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.1 * math.sin(sine / 28), 0) * angles(math.rad(0), math.rad(-8.5 + 8.5 * math.sin(sine / 28)), math.rad(25 + 8.5 * math.sin(sine / 28))), 0.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.05 * math.cos(sine / 32),-0.5)*angles(math.rad(84 - 3 * math.cos(sine / 32)),math.rad(8 - 5 * math.cos(sine / 32)),math.rad(80 - 3 * math.cos(sine / 32))),.1)
    elseif Mode == "FL" then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(20)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(-20)),.1)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.05 * math.cos(sine / 28),-0.2)*angles(math.rad(105),math.rad(0),math.rad(-56)),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.05 * math.cos(sine / 28),-0.2)*angles(math.rad(81),math.rad(0),math.rad(67)),.1)
	elseif Mode == "TP" then
RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.15 * math.cos(sne / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 + 1 * math.cos(sne / 32))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.15 * math.cos(sne / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(0 - 1 * math.cos(sne / 32))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0,0 + 0.15 * math.cos(sne / 25))*angles(math.rad(-3 + 1 * math.cos(sne / 32)),math.rad(0),math.rad(-1)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(5 - 2 * math.cos(sne / 37)),math.rad(0 + 1 * math.cos(sne / 58)),math.rad(1 + 2 * math.cos(sne / 53))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sne / 45),0)*angles(math.rad(2 + 5 * math.cos(sne / 74)),math.rad(1 - 3 * math.cos(sne / 53)),math.rad(14 - 9 * math.cos(sne / 25))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sne / 45),0)*angles(math.rad(5 - 3 * math.cos(sne / 73)),math.rad(2 - 1 * math.cos(sne / 55)),math.rad(-18 + 9 * math.cos(sne / 25))),.1)
	elseif Mode == "ICE" then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.074 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.074 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.074 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(21 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1 + 0.085 * math.cos(sine/28),0.5 + 0.05 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(-30 - 4 * math.cos(sine/28))),.1)
LW.C0=clerp(LW.C0,cf(-1 - 0.085 * math.cos(sine/28),0.5 + 0.05 * math.cos(sine / 28),0.45)*angles(math.rad(-30),math.rad(0),math.rad(30 + 4 * math.cos(sine/28))),.1)
	elseif Mode == "N" then
		if math.random(1,3) == 1 then
		PixelBlockX(7,0.5,"Add",rarm.CFrame*CFrame.new(0,-1.35,0)*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.5,0.5,0.5,0.01,MAINCOLOR,0)
end
sphere2(6,"Add",rarm.CFrame*CFrame.new(math.random(-0.5,0.5),-1.35 + math.random(-0.5,0.5),math.random(-0.5,0.5)),vt(0.45,0.45,0.45),0.01,0.01,0.01,MAINCOLOR,MAINCOLOR.Color)
		RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) - 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1 + 1 * math.cos(sine / 50)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) + 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5 - 1 * math.cos(sine / 50)),math.rad(7),math.rad(0 + 2 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.04 * math.cos(sine / 50),0 + 0.03 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 + 1 * math.cos(sine / 50)),math.rad(18-4*COS(sne/42))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 28)),math.rad(-2 + 3.5 * math.cos(sine / 57)),math.rad(18-4*math.cos(sne/42))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 11 * math.cos(sine / 73)),math.rad(18 - 6 * math.cos(sine / 57)),math.rad(17 + 5 * math.cos(sine / 28))),.1)
--RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0 - 1 * math.cos(sine / 43)),math.rad(-2 + 2 * math.cos(sine / 45)),math.rad(12 + 7 * math.cos(sine / 28))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0 + 1 * math.cos(sine / 49)),math.rad(2 - 2 * math.cos(sine / 52)),math.rad(-12 - 7 * math.cos(sine / 39))),.1)
	elseif Mode == "A" then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 1 * math.cos(sine / 42))),.1)
--Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 - 8.5 * math.cos(sine / 41)),math.rad(0 + 1 * math.cos(sine / 57)),math.rad(20 + 10 * math.cos(sine / 47))),.1)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(8 - 3 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-2 + 2 * math.cos(sine / 53))),.1)
		----RH.C0 = clerp(RH.C0, CF(1, -0.4 - 0.1 * Cos(sine / 32), -0.6) * angles(Rad(0), Rad(75 + 8.5 * Sin(sine / 32)), Rad(0)) * angles(Rad(-8.5), Rad(0), Rad(0)), 0.1)
			----	LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 32), 0) * angles(Rad(0), Rad(-75 - 8.5 * Sin(sine / 32)), Rad(0)) * angles(Rad(-8.5), Rad(0), Rad(0)), 0.1)
		----		RootJoint.C0=clerp(RootJoint.C0,CF(0+.2*SIN(sne/32),1.3-.5*COS(sne/32),0+.2*COS(sne/24))*ANGLES(RAD(270+1.5*SIN(sne/32)),RAD(0+5*SIN(sne/36)),RAD(-180)),.1)
		--		RootJoint.C0=clerp(RootJoint.C0,CF(0+.2*SIN(sne/32),1.3-.5*COS(sne/32),0+.2*COS(sne/24))*ANGLES(RAD(90+1.5*SIN(sne/32)),RAD(0+5*SIN(sne/36)),RAD(180)),.1)
--Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(4 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(-2 + 2 * math.cos(sine / 53))),.1)
			RW.C0=clerp(RW.C0,cf(1,0.45 + 0.1 * math.cos(sine / 56),-0.5)*angles(math.rad(25+5*math.cos(sine/56)),math.rad(-15),math.rad(-85-5*math.cos(sine/56))),.1)
LW.C0=clerp(LW.C0,cf(-0.75,0.45 + 0.1 * math.cos(sine /56),-0.5)*angles(math.rad(-25-5*math.cos(sine/56)),math.rad(15),math.rad(80+10*math.cos(sine/56))),.1)
	elseif Mode == "R" then
		RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.05 * math.cos(sne / 18),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sne / 56)),math.rad(1 - 2 * math.cos(sne / 18))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.05 * math.cos(sne / 18),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(10 - 1 * math.cos(sne / 56)),math.rad(-1 + 2 * math.cos(sne / 18))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sne / 18),0 + 0.05 * math.cos(sne / 18))*angles(math.rad(1 - 2 * math.cos(sne / 18)),math.rad(0),math.rad(-3 + 3 * math.cos(sne / 42))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(15 - 2 * math.cos(sne / 37)),math.rad(0 + 2 * math.cos(sne / 58)),math.rad(-1 + 1 * math.cos(sne / 53))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sne / 45),0)*angles(math.rad(1 + 1 * math.cos(sne / 72)),math.rad(3 - 2 * math.cos(sne / 58)),math.rad(12 + 3 * math.cos(sne / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sne / 45),0)*angles(math.rad(1 - 2 * math.cos(sne / 66)),math.rad(2 - 1 * math.cos(sne / 56)),math.rad(-12 + 3 * math.cos(sne / 45))),.1)
	end
		elseif Chill == true then
RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),0.123 + 0.15 * math.cos(sine / 32))*angles(math.rad(-87 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(183 + 3 * math.cos(sine / 74)),math.rad(2 - 1 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(183 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
	end
end
elseif TorsoVelocity>2 and TorsoVelocity<22 and hitfloor~=nil then
ANIMATIONATION="Walk"
if attacking==false then
			if Chill ~= true then
	--[[
RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.08 * math.cos(sne / 23),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-4),math.rad(0),math.rad(0+35*math.cos(sne/16))),.3)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.08 * math.cos(sne / 23),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-4),math.rad(0),math.rad(0+35*math.cos(sne/16))),.3)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,0,0 + 0.085 * math.cos(sne / 23))*angles(math.rad(8),math.rad(0),math.rad(0)),.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
	]]--
	if turboli == 20 then
		turboli = 0
			if Mode ~= "LS" then
coroutine.resume(coroutine.create(function()
if Mode == "T" then
local turbo = TurboArrow:Clone()
turbo.Parent = Character
turbo.Anchored = true
turbo.CanCollide = false
turbo.CFrame = root.CFrame*cf(0,1.5,3)*angles(math.rad(131),math.rad(-180),math.rad(90))
turbo.Transparency = 0.3
swait(120)
repeat
turbo.Transparency = turbo.Transparency + 0.01
swait()
until turbo.Transparency == 0 or turbo.Transparency > 0.99
game:GetService("Debris"):AddItem(turbo, 4)
end
end))
	end
	end
	turboli = turboli + 1
			if Mode == "G" then
				if math.random(1,5) == 1 then
					sphereMK(0.5,-1,"Add",RootPart.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),-8)*CFrame.Angles(math.rad(math.random(-25,25)),math.rad(math.random(-25,25)),math.rad(math.random(-25,25))),0.5,0.5,10,-0.005,BrickColor.new("Institutional white"),0)	
		end
		--sphereMK(3.5,-1,"Add",LeftLeg.CFrame* CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),0.5,0.5,10,-0.005,BrickColor.new("Institutional white"),0)	
		--sphereMK(3.5,-1,"Add",RightLeg.CFrame* CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))),0.5,0.5,10,-0.005,BrickColor.new("Institutional white"),0)	
		end
RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.15 * math.cos(sne / 17),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 - 45 * math.cos(sne / 17))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.15 * math.cos(sne / 17),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 - 45 * math.cos(sne / 17))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sne / 8.5))*angles(math.rad(11 - 6 * math.sin(sne / 8.5)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - RootPart.RotVelocity.Y - 1 * math.cos(sne / 17))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(-6 + 2 * math.cos(sne / 17)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - Head.RotVelocity.Y*1.5 + 1 * math.cos(sne / 17))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(50 * math.cos(sne / 17)),math.rad(-1),math.rad(7 + 4 * math.cos(sne / 17))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-50 * math.cos(sne / 17)),math.rad(1),math.rad(-7 - 4 * math.cos(sne / 17))),.1)
-- RightS.C0 = clerp2(RightS.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0 - 50 * math.cos(sne / 16)), RAD(0), RAD(12 + 3 *math.cos(sne /16))) * CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.15 / 3)
-- LeftS.C0 = clerp2(LeftS.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0 + 50 * math.cos(sne / 16)), RAD(0), RAD(-12 - 3 * math.cos(sne / 16))) * CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.15 / 3)
	elseif Chill == true then
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),-0.2)*angles(math.rad(-40),math.rad(90),math.rad(0)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),-0.3)*angles(math.rad(-40),math.rad(-90),math.rad(0)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 29),0 + 0.125 * math.cos(sine / 34),0.123 + 0.25 * math.cos(sine / 28))*angles(math.rad(60),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.05)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-35 + 2.5 * math.cos(sine / 41)),math.rad(0 + 1 * math.cos(sine / 57)),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-50 - 0.3 * math.cos(sine / 43)),math.rad(-15 - 2 * math.cos(sine / 52)),math.rad(19 + 0.9 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-50 - 0.2 * math.cos(sine / 51)),math.rad(15 - 4 * math.cos(sine / 64)),math.rad(-19 - 0.2 * math.cos(sine / 45))),.1)
		end
end
elseif TorsoVelocity>=22 and hitfloor~=nil then
ANIMATIONATION="Run"
if attacking==false then
		if Chill ~= true then
	if turboli2 == 12 then
		turboli2 = 0
coroutine.resume(coroutine.create(function()
		if Mode == "LS" then
	local turbo2 = ToothpasteArrow:Clone()
	turbo2.Parent = char
    turbo2.Anchored = true
	turbo2.CanCollide = false
	turbo2.CFrame = root.CFrame*cf(0,1.5,2.65)*angles(math.rad(146),math.rad(-180),math.rad(90))
	turbo2.Transparency = 0.3
swait(120)
repeat
turbo2.Transparency = turbo2.Transparency + 0.01
swait()
until turbo2.Transparency == 0 or turbo2.Transparency > 0.99
game:GetService("Debris"):AddItem(turbo2, 4)	
end
end))
	end
		if Mode == "R" then
		sphereMK(2.5,-1,"Add",RootPart.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),-8)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),0.5,0.5,10,-0.005,BrickColor.new("Institutional white"),0)	
		end
	turboli2 = turboli2 + 2
RightH.C0=clerp(RightH.C0,cf(1,-1 - 0.15 * math.cos(sne / 6),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 - 76 * math.cos(sne / 6))),.1)
LeftH.C0=clerp(LeftH.C0,cf(-1,-1 - 0.15 * math.cos(sne / 6),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0 - 76 * math.cos(sne / 6))),.1)
RootJ.C0=clerp(RootJ.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.sin(sne / 3))*angles(math.rad(26 - 6 * math.cos(sne / 3)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - RootPart.RotVelocity.Y - 1 * math.cos(sne / 23))),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,neckcf*angles(math.rad(-6 + 2 * math.cos(sne / 6)),math.rad(0 + RootPart.RotVelocity.Y*1.5),math.rad(0 - Head.RotVelocity.Y*1.5 + 1 * math.cos(sne / 6))),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(10+90 * math.cos(sne / 6)),math.rad(-1),math.rad(7 + 4 * math.cos(sne / 6))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(10-90 * math.cos(sne / 6)),math.rad(1),math.rad(-7 - 4 * math.cos(sne / 6))),.1)
	elseif Chill == true then--Mode == "A" then --originally was solar mode
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),-0.2)*angles(math.rad(-40),math.rad(90),math.rad(0)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),-0.3)*angles(math.rad(-40),math.rad(-90),math.rad(0)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 29),0 + 0.125 * math.cos(sine / 34),0.115 + 0.25 * math.cos(sine / 28))*angles(math.rad(60),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.05)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-35 + 2.5 * math.cos(sine / 41)),math.rad(0 + 1 * math.cos(sine / 57)),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-50 - 0.3 * math.cos(sine / 43)),math.rad(-15 - 2 * math.cos(sine / 52)),math.rad(19 + 0.9 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-50 - 0.2 * math.cos(sine / 51)),math.rad(15 - 4 * math.cos(sine / 64)),math.rad(-19 - 0.2 * math.cos(sine / 45))),.1)
		end
end
end
end
